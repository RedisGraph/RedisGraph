/*
* Copyright 2018-2020 Redis Labs Ltd. and Contributors
*
* This file is available under the Redis Labs Source Available License Agreement
*/

#include "cmd_bulk_insert.h"
#include "../query_ctx.h"
#include "../util/rmalloc.h"
#include "../util/thpool/pools.h"
#include "../bulk_insert/bulk_insert.h"

#define BATCH_SIZE_LIMIT 1000000 // 1M

// process HEADER token if exists
static int _Graph_Bulk_Header(RedisModuleCtx *ctx, RedisModuleString ***argv,
		int *argc, Graph *g) {
	int res = BULK_OK;
	const char *token = RedisModule_StringPtrLen(**argv, NULL);
	bool header = strcmp(token, "HEADER") == 0;

	if(!header) return BULK_OK;

	// expecting at least 6 arguments
	// HEADER
	// field count (2)
	//     field name
	//     field value
	if(*argc < 6) {
		RedisModule_ReplyWithError(ctx, "Error parsing header.");
		return BULK_FAIL;
	}

	// skip header token
	(*argv) ++;
	(*argc) --;

	// HEADER:
	// total node count
	// total edge count

	long long node_count   = 0;  // number of nodes in graph
	long long edge_count   = 0;  // number of edges in graph
	long long field_count  = 0;  // number of fields in header

	// read number of fields in header
	if(RedisModule_StringToLongLong(**argv, &field_count) != REDISMODULE_OK) {
		RedisModule_ReplyWithError(ctx, "Error parsing header.");
		return BULK_FAIL;
	}
	(*argv) ++;
	(*argc) --;

	// process header fields
	for(int i = 0; i < field_count; i++) {
		// read field name
		token = RedisModule_StringPtrLen(**argv, NULL);
		(*argv) ++;
		(*argc) --;

		//----------------------------------------------------------------------
		// node count
		//----------------------------------------------------------------------

		if(strcmp(token, "NODE_COUNT") == 0) {
			if(RedisModule_StringToLongLong(**argv, &node_count) != REDISMODULE_OK) {
				RedisModule_ReplyWithError(ctx, "Error parsing node count.");
				res = BULK_FAIL;
				break;
			}
			Graph_AllocateNodes(g, node_count);
		}

		//----------------------------------------------------------------------
		// node count
		//----------------------------------------------------------------------

		else if(strcmp(token, "EDGE_COUNT") == 0) {
			if(RedisModule_StringToLongLong(**argv, &edge_count) != REDISMODULE_OK) {
				RedisModule_ReplyWithError(ctx, "Error parsing relation count.");
				res = BULK_FAIL;
				break;
			}
			Graph_AllocateEdges(g, edge_count);
		}

		//----------------------------------------------------------------------
		// unknown field
		//----------------------------------------------------------------------

		else {
			char *err = NULL;
			asprintf(&err, "Error parsing header, unknown field: %s", token);
			RedisModule_ReplyWithError(ctx, err);
			free(err);
			res = BULK_FAIL;
			break;
		}

		(*argv) ++;
		(*argc) --;
	}

	return res;
}

// process "BEGIN" token, expected to be present only on first bulk-insert
// batch, make sure graph key doesn't exists, fails if "BEGIN" token is present
// and graph key 'graphname' already exists
static int _Graph_Bulk_Begin(RedisModuleCtx *ctx, RedisModuleString ***argv,
		int *argc, RedisModuleString *rs_graph_name, bool *begin) {
	ASSERT(argv           !=  NULL);
	ASSERT(argc           !=  NULL);
	ASSERT(begin          !=  NULL);
	ASSERT(rs_graph_name  !=  NULL);

	const char *token = RedisModule_StringPtrLen(**argv, NULL);
	*begin = strcmp(token, "BEGIN") == 0;

	// do nothing if this is not the first BULK call
	if(*begin == false) return BULK_OK;

	// "BEGIN" token present, skip "BEGIN" token
	(*argv) ++;
	(*argc) --;

	RedisModuleKey *key = NULL;
	key = RedisModule_OpenKey(ctx, rs_graph_name, REDISMODULE_READ);
	RedisModule_CloseKey(key);

	if(key) {
		char *err;
		const char *graphname = RedisModule_StringPtrLen(rs_graph_name, NULL);
		asprintf(&err, "Graph with name '%s' cannot be created, \
				as key '%s' already exists.", graphname, graphname);
		RedisModule_ReplyWithError(ctx, err);
		free(err);
		return BULK_FAIL;
	}

	return BULK_OK;
}

// bulk-insert process a batch of node/edge creation generated by the
// bulk-insert utility
int Graph_BulkInsert(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
	ASSERT(ctx != NULL);
	ASSERT(argv != NULL);

	if(argc < 3) return RedisModule_WrongArity(ctx);

	int           res         =  BULK_FAIL;
	GraphContext  *gc         =  NULL;
	long long     node_count  =  0;         // number of declared nodes
	long long     edge_count  =  0;         // number of declared edges

	// unpack arguments
	// get graph name
	argv += 1; // skip "GRAPH.BULK"
	RedisModuleString *rs_graph_name = *argv++;
	argc -= 2; // skip "GRAPH.BULK [GRAPHNAME]"

	//--------------------------------------------------------------------------
	// BEGIN token
	//--------------------------------------------------------------------------

	bool begin = false;
	res = _Graph_Bulk_Begin(ctx, &argv, &argc, rs_graph_name, &begin);
	if(res != BULK_OK) goto cleanup;

	// create key only if "BEGIN" token present
	gc = GraphContext_Retrieve(ctx, rs_graph_name, false, begin);

	// failed to retrieve GraphContext; an error has been emitted
	if(gc == NULL) goto cleanup;

	//--------------------------------------------------------------------------
	// process HEADER
	//--------------------------------------------------------------------------

	// if begin process header (if exists)
	if(begin) {
		res = _Graph_Bulk_Header(ctx, &argv, &argc, gc->g);
		if(res != BULK_OK) goto cleanup;
	}

	// read the user-provided counts for nodes and edges in the current query
	if(RedisModule_StringToLongLong(*argv++, &node_count) != REDISMODULE_OK) {
		RedisModule_ReplyWithError(ctx, "Error parsing node count.");
		goto cleanup;
	}

	if(RedisModule_StringToLongLong(*argv++, &edge_count) != REDISMODULE_OK) {
		RedisModule_ReplyWithError(ctx, "Error parsing relation count.");
		goto cleanup;
	}

	argc -= 2; // read node count and edge count

	// validate batch size
	if(node_count + edge_count > BATCH_SIZE_LIMIT) {
		RedisModule_ReplyWithError(ctx, "Error batch too large to process");
		goto cleanup;
	}

	res = BulkInsert(ctx, gc, argv, argc, node_count, edge_count);

cleanup:
	if(res == BULK_FAIL) {
		if(gc != NULL) {
			// if insertion failed, clean up keyspace and free added entities
			GraphContext_Release(gc);
			RedisModuleKey *key = NULL;

			key = RedisModule_OpenKey(ctx, rs_graph_name, REDISMODULE_WRITE);
			RedisModule_DeleteKey(key);
			RedisModule_CloseKey(key);
		}
	} else {
		// successful bulk commands
		ASSERT(res == BULK_OK);

		// modify slaves
		RedisModule_ReplicateVerbatim(ctx);

		// replay to caller
		char reply[1024];
		int len = snprintf(reply, 1024, "%llu nodes created, %llu edges created",
				node_count, edge_count);
		RedisModule_ReplyWithStringBuffer(ctx, reply, len);
	}

	return REDISMODULE_OK;
}


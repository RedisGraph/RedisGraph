# RedisGraph Data Types

RedisGraph supports a number of distinct data types, some of which can be persisted as property values and some of which are ephemeral.

## Scalar types

All scalar types may be provided by queries or stored as property values on node and relationship objects.

### Strings

RedisGraph strings are Unicode character sequences. When using Redis with a TTY (such as invoking RedisGraph commands from the terminal via `redis-cli`), some code points may not be decoded, as in:

```sh
$ redis-cli GRAPH.QUERY G "RETURN '日本人' as stringval"
1) 1) "stringval"
2) 1) 1) "\xe6\x97\xa5\xe6\x9c\xac\xe4\xba\xba"
```

Output decoding can be forced using the `--raw` flag:

```sh
$ redis-cli --raw GRAPH.QUERY G "RETURN '日本人' as stringval"
stringval
日本人
```

### Booleans

Boolean values are specified as `true` or `false`. Internally, they are stored as numerics, with 1 representing true and 0 representing false. As RedisGraph considers types in its comparisons, 1 is not considered equal to `true`:

```sh
$ redis-cli GRAPH.QUERY G "RETURN 1 = true"
1) 1) "1 = true"
2) 1) 1) "false"
```

### Integers

All RedisGraph integers are treated as 64-bit signed integers.

### Floating-point values

All RedisGraph floating-point values are treated as 64-bit signed doubles.

### Nulls

In RedisGraph, `null` is used to stand in for an unknown or missing value.

Since we cannot reason broadly about unknown values, `null` is an important part of RedisGraph's 3-valued truth table. For example, the comparison `null = null` will evaluate to `null`, as we lack adequate information about the compared values. Similarly, `null in [1,2,3]` evaluates to `null`, since the value we're looking up is unknown.

Unlike all other scalars, `null` cannot be stored as a property value.

## Collection types

### Arrays

Arrays are ordered lists of elements. They can be provided as literals or generated by functions like `collect()`. Nested arrays are supported, as are many functions that operate on arrays such as [list comprehensions](commands.md#list-comprehensions).

Arrays can be stored as property values provided that no array element is of an unserializable type, such as graph entities or `null` values.

### Maps

Maps are order-agnostic collections of key-value pairs. If a key is a string literal, the map can be accessed using dot notation. If it is instead an expression that evaluates to a string literal, bracket notation can be used:

```sh
$ redis-cli GRAPH.QUERY G "WITH {key1: 'stringval', key2: 10} AS map RETURN map.key1, map['key' + 2]"
1) 1) "map.key1"
   2) "map['key' + 2]"
2) 1) 1) "stringval"
      2) (integer) 10
```

This aligns with way that the properties of nodes and relationships can be accessed.

Maps cannot be stored as property values.

#### Map projections

Maps can be constructed as projections using the syntax `alias {.key1 [, ...n]}`. This can provide a useful format for returning graph entities. For example, given a graph with the node `(name: 'Jeff', age: 32)`, we can build the projection:

```sh
$ redis-cli GRAPH.QUERY G "MATCH (n) RETURN n {.name, .age} AS projection"
1) 1) "projection"
2) 1) 1) "{name: Jeff, age: 32}"
```
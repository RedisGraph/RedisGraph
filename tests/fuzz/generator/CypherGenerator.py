# Generated by Grammarinator 19.3+59.gb5a45be

from itertools import chain
from math import inf
from grammarinator.runtime import *


class CypherGenerator(Generator):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    @depthcontrol
    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    @depthcontrol
    def oC_Cypher(self, parent=None):
        current = UnparserRule(name='oC_Cypher', parent=parent)
        self.enter_rule(current)
        self.SP(parent=current)
        self.oC_Statement(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.SP(parent=current)
                UnlexerRule(src=';', parent=current)
        self.SP(parent=current)
        self.EOF(parent=current)
        self.exit_rule(current)
        return current
    oC_Cypher.min_depth = 9

    @depthcontrol
    def oC_Statement(self, parent=None):
        current = UnparserRule(name='oC_Statement', parent=parent)
        self.enter_rule(current)
        self.oC_Query(parent=current)
        self.exit_rule(current)
        return current
    oC_Statement.min_depth = 8

    @depthcontrol
    def oC_Query(self, parent=None):
        current = UnparserRule(name='oC_Query', parent=parent)
        self.enter_rule(current)
        self.oC_RegularQuery(parent=current)
        self.exit_rule(current)
        return current
    oC_Query.min_depth = 7

    @depthcontrol
    def oC_RegularQuery(self, parent=None):
        current = UnparserRule(name='oC_RegularQuery', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(
            current, 0, [0 if [6, 7][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.oC_SinglePartQuery(parent=current)
        elif choice == 1:
            self.oC_MultiPartQuery(parent=current)
        self.exit_rule(current)
        return current
    oC_RegularQuery.min_depth = 6

    @depthcontrol
    def oC_SinglePartQuery(self, parent=None):
        current = UnparserRule(name='oC_SinglePartQuery', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [
                                   0 if [5, 6, 6][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            if self.max_depth >= 6:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    self.oC_ReadingClause(parent=current)
                    self.SP(parent=current)
            self.oC_Return(parent=current)
        elif choice == 1:
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 1, min=1, max=inf):
                    self.oC_ReadingClause(parent=current)
                    self.SP(parent=current)
            self.oC_UpdatingClause(parent=current)
            if self.max_depth >= 6:
                for _ in self.model.quantify(current, 2, min=0, max=inf):
                    self.SP(parent=current)
                    self.oC_UpdatingClause(parent=current)
            if self.max_depth >= 5:
                for _ in self.model.quantify(current, 3, min=0, max=1):
                    self.SP(parent=current)
                    self.oC_Return(parent=current)
        elif choice == 2:
            self.oC_UpdatingStartClause(parent=current)
            if self.max_depth >= 6:
                for _ in self.model.quantify(current, 4, min=0, max=inf):
                    self.SP(parent=current)
                    self.oC_UpdatingClause(parent=current)
            if self.max_depth >= 5:
                for _ in self.model.quantify(current, 5, min=0, max=1):
                    self.SP(parent=current)
                    self.oC_Return(parent=current)
        self.exit_rule(current)
        return current
    oC_SinglePartQuery.min_depth = 5

    @depthcontrol
    def oC_MultiPartQuery(self, parent=None):
        current = UnparserRule(name='oC_MultiPartQuery', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                choice = self.model.choice(
                    current, 0, [0 if [6, 6][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    if self.max_depth >= 0:
                        for _ in self.model.quantify(current, 1, min=1, max=inf):
                            self.oC_ReadingClause(parent=current)
                            self.SP(parent=current)
                    if self.max_depth >= 6:
                        for _ in self.model.quantify(current, 2, min=0, max=inf):
                            self.SP(parent=current)
                            self.oC_UpdatingClause(parent=current)
                elif choice == 1:
                    self.oC_UpdatingStartClause(parent=current)
                    if self.max_depth >= 6:
                        for _ in self.model.quantify(current, 3, min=0, max=inf):
                            self.SP(parent=current)
                            self.oC_UpdatingClause(parent=current)
                self.oC_With(parent=current)
                self.SP(parent=current)
        self.oC_SinglePartQuery(parent=current)
        self.exit_rule(current)
        return current
    oC_MultiPartQuery.min_depth = 6

    @depthcontrol
    def oC_UpdatingStartClause(self, parent=None):
        current = UnparserRule(name='oC_UpdatingStartClause', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(
            current, 0, [0 if [6, 5][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.oC_Create(parent=current)
        elif choice == 1:
            self.oC_Merge(parent=current)
        self.exit_rule(current)
        return current
    oC_UpdatingStartClause.min_depth = 5

    @depthcontrol
    def oC_UpdatingClause(self, parent=None):
        current = UnparserRule(name='oC_UpdatingClause', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [
                                   6, 5, 5, 7][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.oC_Create(parent=current)
        elif choice == 1:
            self.oC_Merge(parent=current)
        elif choice == 2:
            self.oC_Delete(parent=current)
        elif choice == 3:
            self.oC_Set(parent=current)
        self.exit_rule(current)
        return current
    oC_UpdatingClause.min_depth = 5

    @depthcontrol
    def oC_ReadingClause(self, parent=None):
        current = UnparserRule(name='oC_ReadingClause', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(
            current, 0, [0 if [6, 5][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.oC_Match(parent=current)
        elif choice == 1:
            self.oC_Unwind(parent=current)
        self.exit_rule(current)
        return current
    oC_ReadingClause.min_depth = 5

    @depthcontrol
    def oC_Match(self, parent=None):
        current = UnparserRule(name='oC_Match', parent=parent)
        self.enter_rule(current)
        self.MATCH(parent=current)
        self.SP(parent=current)
        self.oC_Pattern(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.SP(parent=current)
                self.oC_Where(parent=current)
        self.exit_rule(current)
        return current
    oC_Match.min_depth = 5

    @depthcontrol
    def OPTIONAL(self, parent=None):
        current = UnlexerRule(name='OPTIONAL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='O', parent=current)
        UnlexerRule(src='P', parent=current)
        UnlexerRule(src='T', parent=current)
        UnlexerRule(src='I', parent=current)
        UnlexerRule(src='O', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='L', parent=current)
        self.exit_rule(current)
        return current
    OPTIONAL.min_depth = 0

    @depthcontrol
    def MATCH(self, parent=None):
        current = UnlexerRule(name='MATCH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='M', parent=current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='T', parent=current)
        UnlexerRule(src='C', parent=current)
        UnlexerRule(src='H', parent=current)
        self.exit_rule(current)
        return current
    MATCH.min_depth = 0

    @depthcontrol
    def oC_Unwind(self, parent=None):
        current = UnparserRule(name='oC_Unwind', parent=parent)
        self.enter_rule(current)
        self.UNWIND(parent=current)
        self.SP(parent=current)
        UnlexerRule(src='[', parent=current)
        self.ZeroDigit(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.SP(parent=current)
                self.NonZeroDigit(parent=current)
        UnlexerRule(src=']', parent=current)
        self.SP(parent=current)
        self.AS(parent=current)
        self.SP(parent=current)
        self.oC_Variable(parent=current)
        self.exit_rule(current)
        return current
    oC_Unwind.min_depth = 4

    @depthcontrol
    def UNWIND(self, parent=None):
        current = UnlexerRule(name='UNWIND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='U', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='W', parent=current)
        UnlexerRule(src='I', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='D', parent=current)
        self.exit_rule(current)
        return current
    UNWIND.min_depth = 0

    @depthcontrol
    def AS(self, parent=None):
        current = UnlexerRule(name='AS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='S', parent=current)
        self.exit_rule(current)
        return current
    AS.min_depth = 0

    @depthcontrol
    def oC_Merge(self, parent=None):
        current = UnparserRule(name='oC_Merge', parent=parent)
        self.enter_rule(current)
        self.MERGE(parent=current)
        self.SP(parent=current)
        self.oC_PatternPart(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.SP(parent=current)
                self.oC_MergeAction(parent=current)
        self.exit_rule(current)
        return current
    oC_Merge.min_depth = 4

    @depthcontrol
    def MERGE(self, parent=None):
        current = UnlexerRule(name='MERGE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='M', parent=current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='R', parent=current)
        UnlexerRule(src='G', parent=current)
        UnlexerRule(src='E', parent=current)
        self.exit_rule(current)
        return current
    MERGE.min_depth = 0

    @depthcontrol
    def oC_MergeAction(self, parent=None):
        current = UnparserRule(name='oC_MergeAction', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(
            current, 0, [0 if [7, 7][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.ON(parent=current)
            self.SP(parent=current)
            self.MATCH(parent=current)
            self.SP(parent=current)
            self.oC_Set(parent=current)
        elif choice == 1:
            self.ON(parent=current)
            self.SP(parent=current)
            self.CREATE(parent=current)
            self.SP(parent=current)
            self.oC_Set(parent=current)
        self.exit_rule(current)
        return current
    oC_MergeAction.min_depth = 7

    @depthcontrol
    def ON(self, parent=None):
        current = UnlexerRule(name='ON', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='O', parent=current)
        UnlexerRule(src='N', parent=current)
        self.exit_rule(current)
        return current
    ON.min_depth = 0

    @depthcontrol
    def CREATE(self, parent=None):
        current = UnlexerRule(name='CREATE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='C', parent=current)
        UnlexerRule(src='R', parent=current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='T', parent=current)
        UnlexerRule(src='E', parent=current)
        self.exit_rule(current)
        return current
    CREATE.min_depth = 0

    @depthcontrol
    def oC_Create(self, parent=None):
        current = UnparserRule(name='oC_Create', parent=parent)
        self.enter_rule(current)
        self.CREATE(parent=current)
        self.SP(parent=current)
        self.oC_Pattern(parent=current)
        self.exit_rule(current)
        return current
    oC_Create.min_depth = 5

    @depthcontrol
    def oC_Set(self, parent=None):
        current = UnparserRule(name='oC_Set', parent=parent)
        self.enter_rule(current)
        self.SET(parent=current)
        self.SP(parent=current)
        self.oC_SetItem(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.SP(parent=current)
                self.oC_SetItem(parent=current)
        self.exit_rule(current)
        return current
    oC_Set.min_depth = 6

    @depthcontrol
    def SET(self, parent=None):
        current = UnlexerRule(name='SET', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='S', parent=current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='T', parent=current)
        self.exit_rule(current)
        return current
    SET.min_depth = 0

    @depthcontrol
    def oC_SetItem(self, parent=None):
        current = UnparserRule(name='oC_SetItem', parent=parent)
        self.enter_rule(current)
        self.oC_PropertyExpression(parent=current)
        self.SP(parent=current)
        UnlexerRule(src='=', parent=current)
        self.SP(parent=current)
        self.rG_Expression(parent=current)
        self.exit_rule(current)
        return current
    oC_SetItem.min_depth = 5

    @depthcontrol
    def oC_Delete(self, parent=None):
        current = UnparserRule(name='oC_Delete', parent=parent)
        self.enter_rule(current)
        self.DETACH(parent=current)
        self.SP(parent=current)
        self.DELETE(parent=current)
        self.SP(parent=current)
        self.oC_Variable(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.SP(parent=current)
                UnlexerRule(src=',', parent=current)
                self.SP(parent=current)
                self.oC_Variable(parent=current)
        self.exit_rule(current)
        return current
    oC_Delete.min_depth = 4

    @depthcontrol
    def DETACH(self, parent=None):
        current = UnlexerRule(name='DETACH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='D', parent=current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='T', parent=current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='C', parent=current)
        UnlexerRule(src='H', parent=current)
        self.exit_rule(current)
        return current
    DETACH.min_depth = 0

    @depthcontrol
    def DELETE(self, parent=None):
        current = UnlexerRule(name='DELETE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='D', parent=current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='L', parent=current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='T', parent=current)
        UnlexerRule(src='E', parent=current)
        self.exit_rule(current)
        return current
    DELETE.min_depth = 0

    @depthcontrol
    def oC_InQueryCall(self, parent=None):
        current = UnparserRule(name='oC_InQueryCall', parent=parent)
        self.enter_rule(current)
        self.CALL(parent=current)
        self.SP(parent=current)
        self.oC_ExplicitProcedureInvocation(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.SP(parent=current)
                self.YIELD(parent=current)
                self.SP(parent=current)
                self.oC_YieldItems(parent=current)
        self.exit_rule(current)
        return current
    oC_InQueryCall.min_depth = 4

    @depthcontrol
    def CALL(self, parent=None):
        current = UnlexerRule(name='CALL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='C', parent=current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='L', parent=current)
        UnlexerRule(src='L', parent=current)
        self.exit_rule(current)
        return current
    CALL.min_depth = 0

    @depthcontrol
    def YIELD(self, parent=None):
        current = UnlexerRule(name='YIELD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='Y', parent=current)
        UnlexerRule(src='I', parent=current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='L', parent=current)
        UnlexerRule(src='D', parent=current)
        self.exit_rule(current)
        return current
    YIELD.min_depth = 0

    @depthcontrol
    def oC_StandaloneCall(self, parent=None):
        current = UnparserRule(name='oC_StandaloneCall', parent=parent)
        self.enter_rule(current)
        self.CALL(parent=current)
        self.SP(parent=current)
        choice = self.model.choice(
            current, 0, [0 if [4, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.oC_ExplicitProcedureInvocation(parent=current)
        elif choice == 1:
            self.oC_ImplicitProcedureInvocation(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.SP(parent=current)
                self.YIELD(parent=current)
                self.SP(parent=current)
                self.oC_YieldItems(parent=current)
        self.exit_rule(current)
        return current
    oC_StandaloneCall.min_depth = 3

    @depthcontrol
    def oC_YieldItems(self, parent=None):
        current = UnparserRule(name='oC_YieldItems', parent=parent)
        self.enter_rule(current)
        self.oC_YieldItem(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.SP(parent=current)
                UnlexerRule(src=',', parent=current)
                self.SP(parent=current)
                self.oC_YieldItem(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.SP(parent=current)
                self.oC_Where(parent=current)
        self.exit_rule(current)
        return current
    oC_YieldItems.min_depth = 5

    @depthcontrol
    def oC_YieldItem(self, parent=None):
        current = UnparserRule(name='oC_YieldItem', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.oC_ProcedureResultField(parent=current)
                self.SP(parent=current)
                self.AS(parent=current)
                self.SP(parent=current)
        self.oC_Variable(parent=current)
        self.exit_rule(current)
        return current
    oC_YieldItem.min_depth = 4

    @depthcontrol
    def oC_With(self, parent=None):
        current = UnparserRule(name='oC_With', parent=parent)
        self.enter_rule(current)
        self.WITH(parent=current)
        self.oC_ProjectionBody(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.SP(parent=current)
                self.oC_Where(parent=current)
        self.exit_rule(current)
        return current
    oC_With.min_depth = 4

    @depthcontrol
    def WITH(self, parent=None):
        current = UnlexerRule(name='WITH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='W', parent=current)
        UnlexerRule(src='I', parent=current)
        UnlexerRule(src='T', parent=current)
        UnlexerRule(src='H', parent=current)
        self.exit_rule(current)
        return current
    WITH.min_depth = 0

    @depthcontrol
    def oC_Return(self, parent=None):
        current = UnparserRule(name='oC_Return', parent=parent)
        self.enter_rule(current)
        self.RETURN(parent=current)
        self.oC_ProjectionBody(parent=current)
        self.exit_rule(current)
        return current
    oC_Return.min_depth = 4

    @depthcontrol
    def RETURN(self, parent=None):
        current = UnlexerRule(name='RETURN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='R', parent=current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='T', parent=current)
        UnlexerRule(src='U', parent=current)
        UnlexerRule(src='R', parent=current)
        UnlexerRule(src='N', parent=current)
        self.exit_rule(current)
        return current
    RETURN.min_depth = 0

    @depthcontrol
    def oC_ProjectionBody(self, parent=None):
        current = UnparserRule(name='oC_ProjectionBody', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.SP(parent=current)
                self.DISTINCT(parent=current)
        self.SP(parent=current)
        self.oC_ProjectionItems(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.SP(parent=current)
                self.oC_Order(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.SP(parent=current)
                self.oC_Skip(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.SP(parent=current)
                self.oC_Limit(parent=current)
        self.exit_rule(current)
        return current
    oC_ProjectionBody.min_depth = 3

    @depthcontrol
    def DISTINCT(self, parent=None):
        current = UnlexerRule(name='DISTINCT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='D', parent=current)
        UnlexerRule(src='I', parent=current)
        UnlexerRule(src='S', parent=current)
        UnlexerRule(src='T', parent=current)
        UnlexerRule(src='I', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='C', parent=current)
        UnlexerRule(src='T', parent=current)
        self.exit_rule(current)
        return current
    DISTINCT.min_depth = 0

    @depthcontrol
    def oC_ProjectionItems(self, parent=None):
        current = UnparserRule(name='oC_ProjectionItems', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(
            current, 0, [0 if [0, 5][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='*', parent=current)
            if self.max_depth >= 5:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    self.SP(parent=current)
                    UnlexerRule(src=',', parent=current)
                    self.SP(parent=current)
                    self.oC_ProjectionItem(parent=current)
        elif choice == 1:
            self.oC_ProjectionItem(parent=current)
            if self.max_depth >= 5:
                for _ in self.model.quantify(current, 1, min=0, max=inf):
                    UnlexerRule(src=',', parent=current)
                    self.SP(parent=current)
                    self.oC_ProjectionItem(parent=current)
        self.exit_rule(current)
        return current
    oC_ProjectionItems.min_depth = 0

    @depthcontrol
    def oC_ProjectionItem(self, parent=None):
        current = UnparserRule(name='oC_ProjectionItem', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(
            current, 0, [0 if [4, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.rG_Expression(parent=current)
            self.SP(parent=current)
            self.AS(parent=current)
            self.SP(parent=current)
            self.oC_Variable(parent=current)
        elif choice == 1:
            self.rG_Expression(parent=current)
        self.exit_rule(current)
        return current
    oC_ProjectionItem.min_depth = 4

    @depthcontrol
    def oC_Order(self, parent=None):
        current = UnparserRule(name='oC_Order', parent=parent)
        self.enter_rule(current)
        self.ORDER(parent=current)
        self.SP(parent=current)
        self.BY(parent=current)
        self.SP(parent=current)
        self.oC_SortItem(parent=current)
        if self.max_depth >= 5:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.SP(parent=current)
                self.oC_SortItem(parent=current)
        self.exit_rule(current)
        return current
    oC_Order.min_depth = 5

    @depthcontrol
    def ORDER(self, parent=None):
        current = UnlexerRule(name='ORDER', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='O', parent=current)
        UnlexerRule(src='R', parent=current)
        UnlexerRule(src='D', parent=current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='R', parent=current)
        self.exit_rule(current)
        return current
    ORDER.min_depth = 0

    @depthcontrol
    def BY(self, parent=None):
        current = UnlexerRule(name='BY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='B', parent=current)
        UnlexerRule(src='Y', parent=current)
        self.exit_rule(current)
        return current
    BY.min_depth = 0

    @depthcontrol
    def oC_Skip(self, parent=None):
        current = UnparserRule(name='oC_Skip', parent=parent)
        self.enter_rule(current)
        self.L_SKIP(parent=current)
        self.SP(parent=current)
        self.DecimalInteger(parent=current)
        self.exit_rule(current)
        return current
    oC_Skip.min_depth = 3

    @depthcontrol
    def L_SKIP(self, parent=None):
        current = UnlexerRule(name='L_SKIP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='S', parent=current)
        UnlexerRule(src='K', parent=current)
        UnlexerRule(src='I', parent=current)
        UnlexerRule(src='P', parent=current)
        self.exit_rule(current)
        return current
    L_SKIP.min_depth = 0

    @depthcontrol
    def oC_Limit(self, parent=None):
        current = UnparserRule(name='oC_Limit', parent=parent)
        self.enter_rule(current)
        self.LIMIT(parent=current)
        self.SP(parent=current)
        self.DecimalInteger(parent=current)
        self.exit_rule(current)
        return current
    oC_Limit.min_depth = 3

    @depthcontrol
    def LIMIT(self, parent=None):
        current = UnlexerRule(name='LIMIT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='L', parent=current)
        UnlexerRule(src='I', parent=current)
        UnlexerRule(src='M', parent=current)
        UnlexerRule(src='I', parent=current)
        UnlexerRule(src='T', parent=current)
        self.exit_rule(current)
        return current
    LIMIT.min_depth = 0

    @depthcontrol
    def oC_SortItem(self, parent=None):
        current = UnparserRule(name='oC_SortItem', parent=parent)
        self.enter_rule(current)
        self.rG_Expression(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.SP(parent=current)
                choice = self.model.choice(current, 0, [0 if [
                                           1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
                if choice == 0:
                    self.ASCENDING(parent=current)
                elif choice == 1:
                    self.ASC(parent=current)
                elif choice == 2:
                    self.DESCENDING(parent=current)
                elif choice == 3:
                    self.DESC(parent=current)
        self.exit_rule(current)
        return current
    oC_SortItem.min_depth = 4

    @depthcontrol
    def ASCENDING(self, parent=None):
        current = UnlexerRule(name='ASCENDING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='S', parent=current)
        UnlexerRule(src='C', parent=current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='D', parent=current)
        UnlexerRule(src='I', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='G', parent=current)
        self.exit_rule(current)
        return current
    ASCENDING.min_depth = 0

    @depthcontrol
    def ASC(self, parent=None):
        current = UnlexerRule(name='ASC', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='S', parent=current)
        UnlexerRule(src='C', parent=current)
        self.exit_rule(current)
        return current
    ASC.min_depth = 0

    @depthcontrol
    def DESCENDING(self, parent=None):
        current = UnlexerRule(name='DESCENDING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='D', parent=current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='S', parent=current)
        UnlexerRule(src='C', parent=current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='D', parent=current)
        UnlexerRule(src='I', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='G', parent=current)
        self.exit_rule(current)
        return current
    DESCENDING.min_depth = 0

    @depthcontrol
    def DESC(self, parent=None):
        current = UnlexerRule(name='DESC', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='D', parent=current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='S', parent=current)
        UnlexerRule(src='C', parent=current)
        self.exit_rule(current)
        return current
    DESC.min_depth = 0

    @depthcontrol
    def oC_Where(self, parent=None):
        current = UnparserRule(name='oC_Where', parent=parent)
        self.enter_rule(current)
        self.WHERE(parent=current)
        self.SP(parent=current)
        self.oC_ComparisonExpression(parent=current)
        self.exit_rule(current)
        return current
    oC_Where.min_depth = 5

    @depthcontrol
    def WHERE(self, parent=None):
        current = UnlexerRule(name='WHERE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='W', parent=current)
        UnlexerRule(src='H', parent=current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='R', parent=current)
        UnlexerRule(src='E', parent=current)
        self.exit_rule(current)
        return current
    WHERE.min_depth = 0

    @depthcontrol
    def oC_Pattern(self, parent=None):
        current = UnparserRule(name='oC_Pattern', parent=parent)
        self.enter_rule(current)
        self.oC_PatternPart(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=',', parent=current)
                self.SP(parent=current)
                self.oC_PatternPart(parent=current)
        self.exit_rule(current)
        return current
    oC_Pattern.min_depth = 4

    @depthcontrol
    def oC_PatternPart(self, parent=None):
        current = UnparserRule(name='oC_PatternPart', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(
            current, 0, [0 if [4, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.oC_Variable(parent=current)
            self.SP(parent=current)
            UnlexerRule(src='=', parent=current)
            self.SP(parent=current)
            self.oC_AnonymousPatternPart(parent=current)
        elif choice == 1:
            self.oC_AnonymousPatternPart(parent=current)
        self.exit_rule(current)
        return current
    oC_PatternPart.min_depth = 3

    @depthcontrol
    def oC_AnonymousPatternPart(self, parent=None):
        current = UnparserRule(name='oC_AnonymousPatternPart', parent=parent)
        self.enter_rule(current)
        self.oC_PatternElement(parent=current)
        self.exit_rule(current)
        return current
    oC_AnonymousPatternPart.min_depth = 2

    @depthcontrol
    def oC_PatternElement(self, parent=None):
        current = UnparserRule(name='oC_PatternElement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(
            current, 0, [0 if [1, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.oC_NodePattern(parent=current)
            if self.max_depth >= 3:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    self.oC_PatternElementChain(parent=current)
        elif choice == 1:
            self.oC_PatternElement(parent=current)
        self.exit_rule(current)
        return current
    oC_PatternElement.min_depth = 1

    @depthcontrol
    def oC_NodePattern(self, parent=None):
        current = UnparserRule(name='oC_NodePattern', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='(', parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.oC_Variable(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.oC_NodeLabels(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.oC_Properties(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    oC_NodePattern.min_depth = 0

    @depthcontrol
    def oC_PatternElementChain(self, parent=None):
        current = UnparserRule(name='oC_PatternElementChain', parent=parent)
        self.enter_rule(current)
        self.oC_RelationshipPattern(parent=current)
        self.oC_NodePattern(parent=current)
        self.exit_rule(current)
        return current
    oC_PatternElementChain.min_depth = 2

    @depthcontrol
    def oC_RelationshipPattern(self, parent=None):
        current = UnparserRule(name='oC_RelationshipPattern', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [
                                   1, 1, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1])])
        if choice == 0:
            self.oC_LeftArrowHead(parent=current)
            self.oC_Dash(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 0, min=0, max=1):
                    self.oC_RelationshipDetail(parent=current)
            self.oC_Dash(parent=current)
            self.oC_RightArrowHead(parent=current)
        elif choice == 1:
            self.oC_LeftArrowHead(parent=current)
            self.oC_Dash(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 1, min=0, max=1):
                    self.oC_RelationshipDetail(parent=current)
            self.oC_Dash(parent=current)
        elif choice == 2:
            self.oC_Dash(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 2, min=0, max=1):
                    self.oC_RelationshipDetail(parent=current)
            self.oC_Dash(parent=current)
            self.oC_RightArrowHead(parent=current)
        elif choice == 3:
            self.oC_Dash(parent=current)
            if self.max_depth >= 1:
                for _ in self.model.quantify(current, 3, min=0, max=1):
                    self.oC_RelationshipDetail(parent=current)
            self.oC_Dash(parent=current)
        self.exit_rule(current)
        return current
    oC_RelationshipPattern.min_depth = 1

    @depthcontrol
    def oC_RelationshipDetail(self, parent=None):
        current = UnparserRule(name='oC_RelationshipDetail', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='[', parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.oC_Variable(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.oC_RelationshipTypes(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.oC_RangeLiteral(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.oC_Properties(parent=current)
        UnlexerRule(src=']', parent=current)
        self.exit_rule(current)
        return current
    oC_RelationshipDetail.min_depth = 0

    @depthcontrol
    def oC_Properties(self, parent=None):
        current = UnparserRule(name='oC_Properties', parent=parent)
        self.enter_rule(current)
        self.oC_MapLiteral(parent=current)
        self.exit_rule(current)
        return current
    oC_Properties.min_depth = 1

    @depthcontrol
    def oC_RelationshipTypes(self, parent=None):
        current = UnparserRule(name='oC_RelationshipTypes', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=':', parent=current)
        self.oC_RelTypeName(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src='|', parent=current)
                self.oC_RelTypeName(parent=current)
        self.exit_rule(current)
        return current
    oC_RelationshipTypes.min_depth = 2

    @depthcontrol
    def oC_NodeLabels(self, parent=None):
        current = UnparserRule(name='oC_NodeLabels', parent=parent)
        self.enter_rule(current)
        self.oC_NodeLabel(parent=current)
        self.exit_rule(current)
        return current
    oC_NodeLabels.min_depth = 3

    @depthcontrol
    def oC_NodeLabel(self, parent=None):
        current = UnparserRule(name='oC_NodeLabel', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=':', parent=current)
        self.oC_LabelName(parent=current)
        self.exit_rule(current)
        return current
    oC_NodeLabel.min_depth = 2

    @depthcontrol
    def oC_RangeLiteral(self, parent=None):
        current = UnparserRule(name='oC_RangeLiteral', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='*', parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.DecimalInteger(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                UnlexerRule(src='..', parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 2, min=0, max=1):
                        self.DecimalInteger(parent=current)
        self.exit_rule(current)
        return current
    oC_RangeLiteral.min_depth = 0

    @depthcontrol
    def oC_LabelName(self, parent=None):
        current = UnparserRule(name='oC_LabelName', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='label', parent=current)
        self.NonZeroDigit(parent=current)
        self.exit_rule(current)
        return current
    oC_LabelName.min_depth = 1

    @depthcontrol
    def oC_RelTypeName(self, parent=None):
        current = UnparserRule(name='oC_RelTypeName', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='reltype', parent=current)
        self.NonZeroDigit(parent=current)
        self.exit_rule(current)
        return current
    oC_RelTypeName.min_depth = 1

    @depthcontrol
    def rG_Expression(self, parent=None):
        current = UnparserRule(name='rG_Expression', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(
            current, 0, [0 if [3, 5][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.oC_Atom(parent=current)
        elif choice == 1:
            self.oC_PropertyExpression(parent=current)
        self.exit_rule(current)
        return current
    rG_Expression.min_depth = 3

    @depthcontrol
    def rG_SimpleExpression(self, parent=None):
        current = UnparserRule(name='rG_SimpleExpression', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(
            current, 0, [0 if [2, 5][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.oC_Literal(parent=current)
        elif choice == 1:
            self.oC_PropertyExpression(parent=current)
        self.exit_rule(current)
        return current
    rG_SimpleExpression.min_depth = 2

    @depthcontrol
    def oC_Expression(self, parent=None):
        current = UnparserRule(name='oC_Expression', parent=parent)
        self.enter_rule(current)
        self.oC_OrExpression(parent=current)
        self.exit_rule(current)
        return current
    oC_Expression.min_depth = 9

    @depthcontrol
    def oC_OrExpression(self, parent=None):
        current = UnparserRule(name='oC_OrExpression', parent=parent)
        self.enter_rule(current)
        self.oC_XorExpression(parent=current)
        if self.max_depth >= 8:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.SP(parent=current)
                self.OR(parent=current)
                self.SP(parent=current)
                self.oC_XorExpression(parent=current)
        self.exit_rule(current)
        return current
    oC_OrExpression.min_depth = 8

    @depthcontrol
    def OR(self, parent=None):
        current = UnlexerRule(name='OR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='O', parent=current)
        UnlexerRule(src='R', parent=current)
        self.exit_rule(current)
        return current
    OR.min_depth = 0

    @depthcontrol
    def oC_XorExpression(self, parent=None):
        current = UnparserRule(name='oC_XorExpression', parent=parent)
        self.enter_rule(current)
        self.oC_AndExpression(parent=current)
        if self.max_depth >= 7:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.SP(parent=current)
                self.XOR(parent=current)
                self.SP(parent=current)
                self.oC_AndExpression(parent=current)
        self.exit_rule(current)
        return current
    oC_XorExpression.min_depth = 7

    @depthcontrol
    def XOR(self, parent=None):
        current = UnlexerRule(name='XOR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='X', parent=current)
        UnlexerRule(src='O', parent=current)
        UnlexerRule(src='R', parent=current)
        self.exit_rule(current)
        return current
    XOR.min_depth = 0

    @depthcontrol
    def oC_AndExpression(self, parent=None):
        current = UnparserRule(name='oC_AndExpression', parent=parent)
        self.enter_rule(current)
        self.oC_NotExpression(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.SP(parent=current)
                self.AND(parent=current)
                self.SP(parent=current)
                self.oC_NotExpression(parent=current)
        self.exit_rule(current)
        return current
    oC_AndExpression.min_depth = 6

    @depthcontrol
    def AND(self, parent=None):
        current = UnlexerRule(name='AND', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='D', parent=current)
        self.exit_rule(current)
        return current
    AND.min_depth = 0

    @depthcontrol
    def oC_NotExpression(self, parent=None):
        current = UnparserRule(name='oC_NotExpression', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.NOT(parent=current)
                self.SP(parent=current)
        self.oC_ComparisonExpression(parent=current)
        self.exit_rule(current)
        return current
    oC_NotExpression.min_depth = 5

    @depthcontrol
    def NOT(self, parent=None):
        current = UnlexerRule(name='NOT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='O', parent=current)
        UnlexerRule(src='T', parent=current)
        self.exit_rule(current)
        return current
    NOT.min_depth = 0

    @depthcontrol
    def oC_ComparisonExpression(self, parent=None):
        current = UnparserRule(name='oC_ComparisonExpression', parent=parent)
        self.enter_rule(current)
        self.rG_SimpleExpression(parent=current)
        self.SP(parent=current)
        self.oC_PartialComparisonExpression(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.SP(parent=current)
                choice = self.model.choice(
                    current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.AND(parent=current)
                elif choice == 1:
                    self.OR(parent=current)
                self.SP(parent=current)
                self.rG_SimpleExpression(parent=current)
                self.SP(parent=current)
                self.oC_PartialComparisonExpression(parent=current)
        self.exit_rule(current)
        return current
    oC_ComparisonExpression.min_depth = 4

    @depthcontrol
    def oC_AddOrSubtractExpression(self, parent=None):
        current = UnparserRule(
            name='oC_AddOrSubtractExpression', parent=parent)
        self.enter_rule(current)
        self.oC_MultiplyDivideModuloExpression(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(
                    current, 0, [0 if [4, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.SP(parent=current)
                    UnlexerRule(src='+', parent=current)
                    self.SP(parent=current)
                    self.oC_MultiplyDivideModuloExpression(parent=current)
                elif choice == 1:
                    self.SP(parent=current)
                    UnlexerRule(src='-', parent=current)
                    self.SP(parent=current)
                    self.oC_MultiplyDivideModuloExpression(parent=current)
        self.exit_rule(current)
        return current
    oC_AddOrSubtractExpression.min_depth = 4

    @depthcontrol
    def oC_MultiplyDivideModuloExpression(self, parent=None):
        current = UnparserRule(
            name='oC_MultiplyDivideModuloExpression', parent=parent)
        self.enter_rule(current)
        self.oC_PowerOfExpression(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(current, 0, [
                                           0 if [3, 3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    self.SP(parent=current)
                    UnlexerRule(src='?', parent=current)
                    self.SP(parent=current)
                    self.oC_PowerOfExpression(parent=current)
                elif choice == 1:
                    self.SP(parent=current)
                    UnlexerRule(src='/', parent=current)
                    self.SP(parent=current)
                    self.oC_PowerOfExpression(parent=current)
                elif choice == 2:
                    self.SP(parent=current)
                    UnlexerRule(src='%', parent=current)
                    self.SP(parent=current)
                    self.oC_PowerOfExpression(parent=current)
        self.exit_rule(current)
        return current
    oC_MultiplyDivideModuloExpression.min_depth = 3

    @depthcontrol
    def oC_PowerOfExpression(self, parent=None):
        current = UnparserRule(name='oC_PowerOfExpression', parent=parent)
        self.enter_rule(current)
        self.oC_UnaryAddOrSubtractExpression(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.SP(parent=current)
                UnlexerRule(src='^', parent=current)
                self.SP(parent=current)
                self.oC_UnaryAddOrSubtractExpression(parent=current)
        self.exit_rule(current)
        return current
    oC_PowerOfExpression.min_depth = 2

    @depthcontrol
    def oC_UnaryAddOrSubtractExpression(self, parent=None):
        current = UnparserRule(
            name='oC_UnaryAddOrSubtractExpression', parent=parent)
        self.enter_rule(current)
        self.oC_StringListNullOperatorExpression(parent=current)
        self.exit_rule(current)
        return current
    oC_UnaryAddOrSubtractExpression.min_depth = 1

    @depthcontrol
    def oC_StringListNullOperatorExpression(self, parent=None):
        current = UnparserRule(
            name='oC_StringListNullOperatorExpression', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                choice = self.model.choice(
                    current, 0, [0 if [5, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.oC_ListOperatorExpression(parent=current)
                elif choice == 1:
                    self.oC_NullOperatorExpression(parent=current)
        self.exit_rule(current)
        return current
    oC_StringListNullOperatorExpression.min_depth = 0

    @depthcontrol
    def oC_ListOperatorExpression(self, parent=None):
        current = UnparserRule(name='oC_ListOperatorExpression', parent=parent)
        self.enter_rule(current)
        self.SP(parent=current)
        UnlexerRule(src='[', parent=current)
        self.rG_Expression(parent=current)
        UnlexerRule(src=']', parent=current)
        self.exit_rule(current)
        return current
    oC_ListOperatorExpression.min_depth = 4

    @depthcontrol
    def IN(self, parent=None):
        current = UnlexerRule(name='IN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='I', parent=current)
        UnlexerRule(src='N', parent=current)
        self.exit_rule(current)
        return current
    IN.min_depth = 0

    @depthcontrol
    def oC_StringOperatorExpression(self, parent=None):
        current = UnparserRule(
            name='oC_StringOperatorExpression', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [
                                   0 if [3, 3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
        if choice == 0:
            self.SP(parent=current)
            self.STARTS(parent=current)
            self.SP(parent=current)
            self.WITH(parent=current)
        elif choice == 1:
            self.SP(parent=current)
            self.ENDS(parent=current)
            self.SP(parent=current)
            self.WITH(parent=current)
        elif choice == 2:
            self.SP(parent=current)
            self.CONTAINS(parent=current)
        self.SP(parent=current)
        self.oC_PropertyOrLabelsExpression(parent=current)
        self.exit_rule(current)
        return current
    oC_StringOperatorExpression.min_depth = 4

    @depthcontrol
    def STARTS(self, parent=None):
        current = UnlexerRule(name='STARTS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='S', parent=current)
        UnlexerRule(src='T', parent=current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='R', parent=current)
        UnlexerRule(src='T', parent=current)
        UnlexerRule(src='S', parent=current)
        self.exit_rule(current)
        return current
    STARTS.min_depth = 0

    @depthcontrol
    def ENDS(self, parent=None):
        current = UnlexerRule(name='ENDS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='D', parent=current)
        UnlexerRule(src='S', parent=current)
        self.exit_rule(current)
        return current
    ENDS.min_depth = 0

    @depthcontrol
    def CONTAINS(self, parent=None):
        current = UnlexerRule(name='CONTAINS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='C', parent=current)
        UnlexerRule(src='O', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='T', parent=current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='I', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='S', parent=current)
        self.exit_rule(current)
        return current
    CONTAINS.min_depth = 0

    @depthcontrol
    def oC_NullOperatorExpression(self, parent=None):
        current = UnparserRule(name='oC_NullOperatorExpression', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(
            current, 0, [0 if [3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.SP(parent=current)
            self.IS(parent=current)
            self.SP(parent=current)
            self.NULL(parent=current)
        elif choice == 1:
            self.SP(parent=current)
            self.IS(parent=current)
            self.SP(parent=current)
            self.NOT(parent=current)
            self.SP(parent=current)
            self.NULL(parent=current)
        self.exit_rule(current)
        return current
    oC_NullOperatorExpression.min_depth = 3

    @depthcontrol
    def IS(self, parent=None):
        current = UnlexerRule(name='IS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='I', parent=current)
        UnlexerRule(src='S', parent=current)
        self.exit_rule(current)
        return current
    IS.min_depth = 0

    @depthcontrol
    def NULL(self, parent=None):
        current = UnlexerRule(name='NULL', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='U', parent=current)
        UnlexerRule(src='L', parent=current)
        UnlexerRule(src='L', parent=current)
        self.exit_rule(current)
        return current
    NULL.min_depth = 0

    @depthcontrol
    def oC_PropertyOrLabelsExpression(self, parent=None):
        current = UnparserRule(
            name='oC_PropertyOrLabelsExpression', parent=parent)
        self.enter_rule(current)
        self.oC_Atom(parent=current)
        self.oC_PropertyLookup(parent=current)
        self.exit_rule(current)
        return current
    oC_PropertyOrLabelsExpression.min_depth = 3

    @depthcontrol
    def oC_Atom(self, parent=None):
        current = UnparserRule(name='oC_Atom', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(
            current, 0, [0 if [2, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.oC_Literal(parent=current)
        elif choice == 1:
            self.oC_Variable(parent=current)
        self.exit_rule(current)
        return current
    oC_Atom.min_depth = 2

    @depthcontrol
    def COUNT(self, parent=None):
        current = UnlexerRule(name='COUNT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='C', parent=current)
        UnlexerRule(src='O', parent=current)
        UnlexerRule(src='U', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='T', parent=current)
        self.exit_rule(current)
        return current
    COUNT.min_depth = 0

    @depthcontrol
    def ANY(self, parent=None):
        current = UnlexerRule(name='ANY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='Y', parent=current)
        self.exit_rule(current)
        return current
    ANY.min_depth = 0

    @depthcontrol
    def NONE(self, parent=None):
        current = UnlexerRule(name='NONE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='O', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='E', parent=current)
        self.exit_rule(current)
        return current
    NONE.min_depth = 0

    @depthcontrol
    def SINGLE(self, parent=None):
        current = UnlexerRule(name='SINGLE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='S', parent=current)
        UnlexerRule(src='I', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='G', parent=current)
        UnlexerRule(src='L', parent=current)
        UnlexerRule(src='E', parent=current)
        self.exit_rule(current)
        return current
    SINGLE.min_depth = 0

    @depthcontrol
    def oC_Literal(self, parent=None):
        current = UnparserRule(name='oC_Literal', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [
                                   4, 1, 2, 1, 4][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            self.oC_NumberLiteral(parent=current)
        elif choice == 1:
            self.StringLiteral(parent=current)
        elif choice == 2:
            self.oC_BooleanLiteral(parent=current)
        elif choice == 3:
            self.NULL(parent=current)
        elif choice == 4:
            self.oC_ListLiteral(parent=current)
        self.exit_rule(current)
        return current
    oC_Literal.min_depth = 1

    @depthcontrol
    def oC_BooleanLiteral(self, parent=None):
        current = UnparserRule(name='oC_BooleanLiteral', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(
            current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.TRUE(parent=current)
        elif choice == 1:
            self.FALSE(parent=current)
        self.exit_rule(current)
        return current
    oC_BooleanLiteral.min_depth = 1

    @depthcontrol
    def TRUE(self, parent=None):
        current = UnlexerRule(name='TRUE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='T', parent=current)
        UnlexerRule(src='R', parent=current)
        UnlexerRule(src='U', parent=current)
        UnlexerRule(src='E', parent=current)
        self.exit_rule(current)
        return current
    TRUE.min_depth = 0

    @depthcontrol
    def FALSE(self, parent=None):
        current = UnlexerRule(name='FALSE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='F', parent=current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='L', parent=current)
        UnlexerRule(src='S', parent=current)
        UnlexerRule(src='E', parent=current)
        self.exit_rule(current)
        return current
    FALSE.min_depth = 0

    @depthcontrol
    def oC_ListLiteral(self, parent=None):
        current = UnparserRule(name='oC_ListLiteral', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='[', parent=current)
        self.SP(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.rG_Expression(parent=current)
                self.SP(parent=current)
                if self.max_depth >= 4:
                    for _ in self.model.quantify(current, 1, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.SP(parent=current)
                        self.rG_Expression(parent=current)
                        self.SP(parent=current)
        UnlexerRule(src=']', parent=current)
        self.exit_rule(current)
        return current
    oC_ListLiteral.min_depth = 3

    @depthcontrol
    def oC_PartialComparisonExpression(self, parent=None):
        current = UnparserRule(
            name='oC_PartialComparisonExpression', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [
                                   3, 3, 3, 3, 3, 3][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='=', parent=current)
            self.SP(parent=current)
            choice = self.model.choice(
                current, 1, [0 if [3, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.rG_SimpleExpression(parent=current)
            elif choice == 1:
                self.oC_Literal(parent=current)
        elif choice == 1:
            UnlexerRule(src='<>', parent=current)
            self.SP(parent=current)
            choice = self.model.choice(
                current, 2, [0 if [3, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.rG_SimpleExpression(parent=current)
            elif choice == 1:
                self.oC_Literal(parent=current)
        elif choice == 2:
            UnlexerRule(src='<', parent=current)
            self.SP(parent=current)
            choice = self.model.choice(
                current, 3, [0 if [3, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.rG_SimpleExpression(parent=current)
            elif choice == 1:
                self.oC_Literal(parent=current)
        elif choice == 3:
            UnlexerRule(src='>', parent=current)
            self.SP(parent=current)
            choice = self.model.choice(
                current, 4, [0 if [3, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.rG_SimpleExpression(parent=current)
            elif choice == 1:
                self.oC_Literal(parent=current)
        elif choice == 4:
            UnlexerRule(src='<=', parent=current)
            self.SP(parent=current)
            choice = self.model.choice(
                current, 5, [0 if [3, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.rG_SimpleExpression(parent=current)
            elif choice == 1:
                self.oC_Literal(parent=current)
        elif choice == 5:
            UnlexerRule(src='>=', parent=current)
            self.SP(parent=current)
            choice = self.model.choice(
                current, 6, [0 if [3, 2][i] > self.max_depth else w for i, w in enumerate([1, 1])])
            if choice == 0:
                self.rG_SimpleExpression(parent=current)
            elif choice == 1:
                self.oC_Literal(parent=current)
        self.exit_rule(current)
        return current
    oC_PartialComparisonExpression.min_depth = 3

    @depthcontrol
    def oC_RelationshipsPattern(self, parent=None):
        current = UnparserRule(name='oC_RelationshipsPattern', parent=parent)
        self.enter_rule(current)
        self.oC_NodePattern(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.SP(parent=current)
                self.oC_PatternElementChain(parent=current)
        self.exit_rule(current)
        return current
    oC_RelationshipsPattern.min_depth = 3

    @depthcontrol
    def oC_FilterExpression(self, parent=None):
        current = UnparserRule(name='oC_FilterExpression', parent=parent)
        self.enter_rule(current)
        self.oC_IdInColl(parent=current)
        if self.max_depth >= 6:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.SP(parent=current)
                self.oC_Where(parent=current)
        self.exit_rule(current)
        return current
    oC_FilterExpression.min_depth = 5

    @depthcontrol
    def oC_IdInColl(self, parent=None):
        current = UnparserRule(name='oC_IdInColl', parent=parent)
        self.enter_rule(current)
        self.oC_Variable(parent=current)
        self.SP(parent=current)
        self.IN(parent=current)
        self.SP(parent=current)
        self.oC_PropertyOrLabelsExpression(parent=current)
        self.exit_rule(current)
        return current
    oC_IdInColl.min_depth = 4

    @depthcontrol
    def oC_FunctionInvocation(self, parent=None):
        current = UnparserRule(name='oC_FunctionInvocation', parent=parent)
        self.enter_rule(current)
        self.oC_FunctionName(parent=current)
        UnlexerRule(src='(', parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.DISTINCT(parent=current)
                self.SP(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.rG_SimpleExpression(parent=current)
                self.SP(parent=current)
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 2, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.SP(parent=current)
                        self.rG_SimpleExpression(parent=current)
                        self.SP(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    oC_FunctionInvocation.min_depth = 4

    @depthcontrol
    def oC_FunctionName(self, parent=None):
        current = UnparserRule(name='oC_FunctionName', parent=parent)
        self.enter_rule(current)
        self.oC_SymbolicName(parent=current)
        self.exit_rule(current)
        return current
    oC_FunctionName.min_depth = 3

    @depthcontrol
    def oC_ExplicitProcedureInvocation(self, parent=None):
        current = UnparserRule(
            name='oC_ExplicitProcedureInvocation', parent=parent)
        self.enter_rule(current)
        self.oC_ProcedureName(parent=current)
        UnlexerRule(src='(', parent=current)
        self.SP(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.rG_SimpleExpression(parent=current)
                self.SP(parent=current)
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 1, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.SP(parent=current)
                        self.rG_SimpleExpression(parent=current)
                        self.SP(parent=current)
        UnlexerRule(src=')', parent=current)
        self.exit_rule(current)
        return current
    oC_ExplicitProcedureInvocation.min_depth = 3

    @depthcontrol
    def oC_ImplicitProcedureInvocation(self, parent=None):
        current = UnparserRule(
            name='oC_ImplicitProcedureInvocation', parent=parent)
        self.enter_rule(current)
        self.oC_ProcedureName(parent=current)
        self.exit_rule(current)
        return current
    oC_ImplicitProcedureInvocation.min_depth = 1

    @depthcontrol
    def oC_ProcedureResultField(self, parent=None):
        current = UnparserRule(name='oC_ProcedureResultField', parent=parent)
        self.enter_rule(current)
        self.oC_SymbolicName(parent=current)
        self.exit_rule(current)
        return current
    oC_ProcedureResultField.min_depth = 3

    @depthcontrol
    def oC_ProcedureName(self, parent=None):
        current = UnparserRule(name='oC_ProcedureName', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [
                                   0, 0, 0, 0, 0, 0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='algo.bfs', parent=current)
        elif choice == 1:
            UnlexerRule(src='algo.pagerank', parent=current)
        elif choice == 2:
            UnlexerRule(src='db.idx.fulltext.createnodeindex', parent=current)
        elif choice == 3:
            UnlexerRule(src='db.idx.fulltext.drop', parent=current)
        elif choice == 4:
            UnlexerRule(src='db.idx.fulltext.querynodes', parent=current)
        elif choice == 5:
            UnlexerRule(src='db.labels', parent=current)
        elif choice == 6:
            UnlexerRule(src='db.propertykeys', parent=current)
        elif choice == 7:
            UnlexerRule(src='db.relationshiptypes', parent=current)
        elif choice == 8:
            UnlexerRule(src='dbms.procedures', parent=current)
        self.exit_rule(current)
        return current
    oC_ProcedureName.min_depth = 0

    @depthcontrol
    def oC_ListComprehension(self, parent=None):
        current = UnparserRule(name='oC_ListComprehension', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='[', parent=current)
        self.SP(parent=current)
        self.oC_FilterExpression(parent=current)
        if self.max_depth >= 10:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.SP(parent=current)
                UnlexerRule(src='|', parent=current)
                self.SP(parent=current)
                self.oC_Expression(parent=current)
        self.SP(parent=current)
        UnlexerRule(src=']', parent=current)
        self.exit_rule(current)
        return current
    oC_ListComprehension.min_depth = 6

    @depthcontrol
    def oC_PatternComprehension(self, parent=None):
        current = UnparserRule(name='oC_PatternComprehension', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='[', parent=current)
        self.SP(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.oC_Variable(parent=current)
                self.SP(parent=current)
                UnlexerRule(src='=', parent=current)
                self.SP(parent=current)
        self.oC_RelationshipsPattern(parent=current)
        self.SP(parent=current)
        if self.max_depth >= 10:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.WHERE(parent=current)
                self.SP(parent=current)
                self.oC_Expression(parent=current)
                self.SP(parent=current)
        UnlexerRule(src='|', parent=current)
        self.SP(parent=current)
        self.oC_Expression(parent=current)
        self.SP(parent=current)
        UnlexerRule(src=']', parent=current)
        self.exit_rule(current)
        return current
    oC_PatternComprehension.min_depth = 10

    @depthcontrol
    def oC_PropertyLookup(self, parent=None):
        current = UnparserRule(name='oC_PropertyLookup', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='.', parent=current)
        self.oC_PropertyKeyName(parent=current)
        self.exit_rule(current)
        return current
    oC_PropertyLookup.min_depth = 2

    @depthcontrol
    def oC_CaseExpression(self, parent=None):
        current = UnparserRule(name='oC_CaseExpression', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(
            current, 0, [0 if [4, 4][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.CASE(parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=1, max=inf):
                    self.SP(parent=current)
                    self.oC_CaseAlternatives(parent=current)
        elif choice == 1:
            self.CASE(parent=current)
            self.SP(parent=current)
            self.rG_SimpleExpression(parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 1, min=1, max=inf):
                    self.SP(parent=current)
                    self.oC_CaseAlternatives(parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 2, min=0, max=1):
                self.SP(parent=current)
                self.ELSE(parent=current)
                self.SP(parent=current)
                self.rG_SimpleExpression(parent=current)
        self.SP(parent=current)
        self.END(parent=current)
        self.exit_rule(current)
        return current
    oC_CaseExpression.min_depth = 4

    @depthcontrol
    def CASE(self, parent=None):
        current = UnlexerRule(name='CASE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='C', parent=current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='S', parent=current)
        UnlexerRule(src='E', parent=current)
        self.exit_rule(current)
        return current
    CASE.min_depth = 0

    @depthcontrol
    def ELSE(self, parent=None):
        current = UnlexerRule(name='ELSE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='L', parent=current)
        UnlexerRule(src='S', parent=current)
        UnlexerRule(src='E', parent=current)
        self.exit_rule(current)
        return current
    ELSE.min_depth = 0

    @depthcontrol
    def END(self, parent=None):
        current = UnlexerRule(name='END', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='D', parent=current)
        self.exit_rule(current)
        return current
    END.min_depth = 0

    @depthcontrol
    def oC_CaseAlternatives(self, parent=None):
        current = UnparserRule(name='oC_CaseAlternatives', parent=parent)
        self.enter_rule(current)
        self.WHEN(parent=current)
        self.SP(parent=current)
        self.rG_SimpleExpression(parent=current)
        self.SP(parent=current)
        self.THEN(parent=current)
        self.SP(parent=current)
        self.rG_SimpleExpression(parent=current)
        self.exit_rule(current)
        return current
    oC_CaseAlternatives.min_depth = 3

    @depthcontrol
    def WHEN(self, parent=None):
        current = UnlexerRule(name='WHEN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='W', parent=current)
        UnlexerRule(src='H', parent=current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='N', parent=current)
        self.exit_rule(current)
        return current
    WHEN.min_depth = 0

    @depthcontrol
    def THEN(self, parent=None):
        current = UnlexerRule(name='THEN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='T', parent=current)
        UnlexerRule(src='H', parent=current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='N', parent=current)
        self.exit_rule(current)
        return current
    THEN.min_depth = 0

    @depthcontrol
    def oC_Variable(self, parent=None):
        current = UnparserRule(name='oC_Variable', parent=parent)
        self.enter_rule(current)
        self.oC_SymbolicName(parent=current)
        self.exit_rule(current)
        return current
    oC_Variable.min_depth = 3

    @depthcontrol
    def StringLiteral(self, parent=None):
        current = UnlexerRule(name='StringLiteral', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='\'', parent=current)
        UnlexerRule(src='LIT', parent=current)
        UnlexerRule(src=self.model.charset(
            current, 0, self._charsets[1]), parent=current)
        UnlexerRule(src='\'', parent=current)
        self.exit_rule(current)
        return current
    StringLiteral.min_depth = 0

    @depthcontrol
    def oC_NumberLiteral(self, parent=None):
        current = UnparserRule(name='oC_NumberLiteral', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(
            current, 0, [0 if [4, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.oC_DoubleLiteral(parent=current)
        elif choice == 1:
            self.oC_IntegerLiteral(parent=current)
        self.exit_rule(current)
        return current
    oC_NumberLiteral.min_depth = 3

    @depthcontrol
    def oC_MapLiteral(self, parent=None):
        current = UnparserRule(name='oC_MapLiteral', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='{', parent=current)
        if self.max_depth >= 3:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.oC_PropertyKeyName(parent=current)
                UnlexerRule(src=':', parent=current)
                self.rG_SimpleExpression(parent=current)
                if self.max_depth >= 3:
                    for _ in self.model.quantify(current, 1, min=0, max=inf):
                        UnlexerRule(src=',', parent=current)
                        self.SP(parent=current)
                        self.oC_PropertyKeyName(parent=current)
                        UnlexerRule(src=':', parent=current)
                        self.rG_SimpleExpression(parent=current)
        UnlexerRule(src='}', parent=current)
        self.exit_rule(current)
        return current
    oC_MapLiteral.min_depth = 0

    @depthcontrol
    def oC_PropertyExpression(self, parent=None):
        current = UnparserRule(name='oC_PropertyExpression', parent=parent)
        self.enter_rule(current)
        self.oC_Variable(parent=current)
        self.oC_PropertyLookup(parent=current)
        self.exit_rule(current)
        return current
    oC_PropertyExpression.min_depth = 4

    @depthcontrol
    def oC_PropertyKeyName(self, parent=None):
        current = UnparserRule(name='oC_PropertyKeyName', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='prop', parent=current)
        self.NonZeroDigit(parent=current)
        self.exit_rule(current)
        return current
    oC_PropertyKeyName.min_depth = 1

    @depthcontrol
    def oC_IntegerLiteral(self, parent=None):
        current = UnparserRule(name='oC_IntegerLiteral', parent=parent)
        self.enter_rule(current)
        self.DecimalInteger(parent=current)
        self.exit_rule(current)
        return current
    oC_IntegerLiteral.min_depth = 2

    @depthcontrol
    def DecimalInteger(self, parent=None):
        current = UnlexerRule(name='DecimalInteger', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(
            current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.ZeroDigit(parent=current)
        elif choice == 1:
            self.NonZeroDigit(parent=current)
            if self.max_depth >= 2:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    self.Digit(parent=current)
        self.exit_rule(current)
        return current
    DecimalInteger.min_depth = 1

    @depthcontrol
    def Digit(self, parent=None):
        current = UnlexerRule(name='Digit', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(
            current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.ZeroDigit(parent=current)
        elif choice == 1:
            self.NonZeroDigit(parent=current)
        self.exit_rule(current)
        return current
    Digit.min_depth = 1

    @depthcontrol
    def NonZeroDigit(self, parent=None):
        current = UnlexerRule(name='NonZeroDigit', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [
                                   0, 0, 0, 0, 0, 0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='1', parent=current)
        elif choice == 1:
            UnlexerRule(src='2', parent=current)
        elif choice == 2:
            UnlexerRule(src='3', parent=current)
        elif choice == 3:
            UnlexerRule(src='4', parent=current)
        elif choice == 4:
            UnlexerRule(src='5', parent=current)
        elif choice == 5:
            UnlexerRule(src='6', parent=current)
        elif choice == 6:
            UnlexerRule(src='7', parent=current)
        elif choice == 7:
            UnlexerRule(src='8', parent=current)
        elif choice == 8:
            UnlexerRule(src='9', parent=current)
        self.exit_rule(current)
        return current
    NonZeroDigit.min_depth = 0

    @depthcontrol
    def ZeroDigit(self, parent=None):
        current = UnlexerRule(name='ZeroDigit', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='0', parent=current)
        self.exit_rule(current)
        return current
    ZeroDigit.min_depth = 0

    @depthcontrol
    def oC_DoubleLiteral(self, parent=None):
        current = UnparserRule(name='oC_DoubleLiteral', parent=parent)
        self.enter_rule(current)
        self.RegularDecimalReal(parent=current)
        self.exit_rule(current)
        return current
    oC_DoubleLiteral.min_depth = 3

    @depthcontrol
    def RegularDecimalReal(self, parent=None):
        current = UnlexerRule(name='RegularDecimalReal', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.Digit(parent=current)
        UnlexerRule(src='.', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=1, max=inf):
                self.Digit(parent=current)
        self.exit_rule(current)
        return current
    RegularDecimalReal.min_depth = 2

    @depthcontrol
    def oC_ReservedWord(self, parent=None):
        current = UnparserRule(name='oC_ReservedWord', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i]
                                   > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.ASC(parent=current)
        elif choice == 1:
            self.ASCENDING(parent=current)
        elif choice == 2:
            self.BY(parent=current)
        elif choice == 3:
            self.CREATE(parent=current)
        elif choice == 4:
            self.DELETE(parent=current)
        elif choice == 5:
            self.DESC(parent=current)
        elif choice == 6:
            self.DESCENDING(parent=current)
        elif choice == 7:
            self.DETACH(parent=current)
        elif choice == 8:
            self.LIMIT(parent=current)
        elif choice == 9:
            self.MATCH(parent=current)
        elif choice == 10:
            self.MERGE(parent=current)
        elif choice == 11:
            self.ON(parent=current)
        elif choice == 12:
            self.OPTIONAL(parent=current)
        elif choice == 13:
            self.ORDER(parent=current)
        elif choice == 14:
            self.RETURN(parent=current)
        elif choice == 15:
            self.SET(parent=current)
        elif choice == 16:
            self.L_SKIP(parent=current)
        elif choice == 17:
            self.WHERE(parent=current)
        elif choice == 18:
            self.WITH(parent=current)
        elif choice == 19:
            self.UNWIND(parent=current)
        elif choice == 20:
            self.AND(parent=current)
        elif choice == 21:
            self.AS(parent=current)
        elif choice == 22:
            self.CONTAINS(parent=current)
        elif choice == 23:
            self.DISTINCT(parent=current)
        elif choice == 24:
            self.ENDS(parent=current)
        elif choice == 25:
            self.IN(parent=current)
        elif choice == 26:
            self.IS(parent=current)
        elif choice == 27:
            self.NOT(parent=current)
        elif choice == 28:
            self.OR(parent=current)
        elif choice == 29:
            self.STARTS(parent=current)
        elif choice == 30:
            self.XOR(parent=current)
        elif choice == 31:
            self.FALSE(parent=current)
        elif choice == 32:
            self.TRUE(parent=current)
        elif choice == 33:
            self.NULL(parent=current)
        elif choice == 34:
            self.CONSTRAINT(parent=current)
        elif choice == 35:
            self.DO(parent=current)
        elif choice == 36:
            self.FOR(parent=current)
        elif choice == 37:
            self.REQUIRE(parent=current)
        elif choice == 38:
            self.UNIQUE(parent=current)
        elif choice == 39:
            self.CASE(parent=current)
        elif choice == 40:
            self.WHEN(parent=current)
        elif choice == 41:
            self.THEN(parent=current)
        elif choice == 42:
            self.ELSE(parent=current)
        elif choice == 43:
            self.END(parent=current)
        elif choice == 44:
            self.MANDATORY(parent=current)
        elif choice == 45:
            self.SCALAR(parent=current)
        elif choice == 46:
            self.OF(parent=current)
        elif choice == 47:
            self.ADD(parent=current)
        elif choice == 48:
            self.DROP(parent=current)
        self.exit_rule(current)
        return current
    oC_ReservedWord.min_depth = 1

    @depthcontrol
    def CONSTRAINT(self, parent=None):
        current = UnlexerRule(name='CONSTRAINT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='C', parent=current)
        UnlexerRule(src='O', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='S', parent=current)
        UnlexerRule(src='T', parent=current)
        UnlexerRule(src='R', parent=current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='I', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='T', parent=current)
        self.exit_rule(current)
        return current
    CONSTRAINT.min_depth = 0

    @depthcontrol
    def DO(self, parent=None):
        current = UnlexerRule(name='DO', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='D', parent=current)
        UnlexerRule(src='O', parent=current)
        self.exit_rule(current)
        return current
    DO.min_depth = 0

    @depthcontrol
    def FOR(self, parent=None):
        current = UnlexerRule(name='FOR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='F', parent=current)
        UnlexerRule(src='O', parent=current)
        UnlexerRule(src='R', parent=current)
        self.exit_rule(current)
        return current
    FOR.min_depth = 0

    @depthcontrol
    def REQUIRE(self, parent=None):
        current = UnlexerRule(name='REQUIRE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='R', parent=current)
        UnlexerRule(src='E', parent=current)
        UnlexerRule(src='Q', parent=current)
        UnlexerRule(src='U', parent=current)
        UnlexerRule(src='I', parent=current)
        UnlexerRule(src='R', parent=current)
        UnlexerRule(src='E', parent=current)
        self.exit_rule(current)
        return current
    REQUIRE.min_depth = 0

    @depthcontrol
    def UNIQUE(self, parent=None):
        current = UnlexerRule(name='UNIQUE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='U', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='I', parent=current)
        UnlexerRule(src='Q', parent=current)
        UnlexerRule(src='U', parent=current)
        UnlexerRule(src='E', parent=current)
        self.exit_rule(current)
        return current
    UNIQUE.min_depth = 0

    @depthcontrol
    def MANDATORY(self, parent=None):
        current = UnlexerRule(name='MANDATORY', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='M', parent=current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='N', parent=current)
        UnlexerRule(src='D', parent=current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='T', parent=current)
        UnlexerRule(src='O', parent=current)
        UnlexerRule(src='R', parent=current)
        UnlexerRule(src='Y', parent=current)
        self.exit_rule(current)
        return current
    MANDATORY.min_depth = 0

    @depthcontrol
    def SCALAR(self, parent=None):
        current = UnlexerRule(name='SCALAR', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='S', parent=current)
        UnlexerRule(src='C', parent=current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='L', parent=current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='R', parent=current)
        self.exit_rule(current)
        return current
    SCALAR.min_depth = 0

    @depthcontrol
    def OF(self, parent=None):
        current = UnlexerRule(name='OF', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='O', parent=current)
        UnlexerRule(src='F', parent=current)
        self.exit_rule(current)
        return current
    OF.min_depth = 0

    @depthcontrol
    def ADD(self, parent=None):
        current = UnlexerRule(name='ADD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='A', parent=current)
        UnlexerRule(src='D', parent=current)
        UnlexerRule(src='D', parent=current)
        self.exit_rule(current)
        return current
    ADD.min_depth = 0

    @depthcontrol
    def DROP(self, parent=None):
        current = UnlexerRule(name='DROP', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='D', parent=current)
        UnlexerRule(src='R', parent=current)
        UnlexerRule(src='O', parent=current)
        UnlexerRule(src='P', parent=current)
        self.exit_rule(current)
        return current
    DROP.min_depth = 0

    @depthcontrol
    def oC_SymbolicName(self, parent=None):
        current = UnparserRule(name='oC_SymbolicName', parent=parent)
        self.enter_rule(current)
        self.EscapedSymbolicName(parent=current)
        self.exit_rule(current)
        return current
    oC_SymbolicName.min_depth = 2

    @depthcontrol
    def EscapedSymbolicName(self, parent=None):
        current = UnlexerRule(name='EscapedSymbolicName', parent=parent)
        self.enter_rule(current)
        self.EscapedSymbolicName_0(parent=current)
        self.exit_rule(current)
        return current
    EscapedSymbolicName.min_depth = 1

    @depthcontrol
    def SP(self, parent=None):
        current = UnlexerRule(name='SP', parent=parent)
        self.enter_rule(current)
        self.WHITESPACE(parent=current)
        self.exit_rule(current)
        return current
    SP.min_depth = 2

    @depthcontrol
    def WHITESPACE(self, parent=None):
        current = UnlexerRule(name='WHITESPACE', parent=parent)
        self.enter_rule(current)
        self.SPACE(parent=current)
        self.exit_rule(current)
        return current
    WHITESPACE.min_depth = 1

    @depthcontrol
    def oC_LeftArrowHead(self, parent=None):
        current = UnparserRule(name='oC_LeftArrowHead', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<', parent=current)
        self.exit_rule(current)
        return current
    oC_LeftArrowHead.min_depth = 0

    @depthcontrol
    def oC_RightArrowHead(self, parent=None):
        current = UnparserRule(name='oC_RightArrowHead', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='>', parent=current)
        self.exit_rule(current)
        return current
    oC_RightArrowHead.min_depth = 0

    @depthcontrol
    def oC_Dash(self, parent=None):
        current = UnparserRule(name='oC_Dash', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='-', parent=current)
        self.exit_rule(current)
        return current
    oC_Dash.min_depth = 0

    @depthcontrol
    def EscapedSymbolicName_0(self, parent=None):
        current = UnlexerRule(name='EscapedSymbolicName_0', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='var', parent=current)
        UnlexerRule(src=self.model.charset(
            current, 0, self._charsets[2]), parent=current)
        self.exit_rule(current)
        return current
    EscapedSymbolicName_0.min_depth = 0

    @depthcontrol
    def SPACE(self, parent=None):
        current = UnlexerRule(name='SPACE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.model.charset(
            current, 0, self._charsets[3]), parent=current)
        self.exit_rule(current)
        return current
    SPACE.min_depth = 0

    default_rule = oC_Cypher

    _charsets = {
        0: list(chain.from_iterable([range(32, 127)])),
        1: list(chain.from_iterable([range(48, 58)])),
        2: list(chain.from_iterable([range(49, 58)])),
        3: list(chain.from_iterable([range(32, 33)])),
    }

const char* const templates_denseDotProduct_cu = "templates/denseDotProduct.cu\n"
"//------------------------------------------------------------------------------\n"
"// denseDotProduct.cu \n"
"//------------------------------------------------------------------------------\n"
"\n"
"// The denseDotProduct CUDA kernel produces the semi-ring dot product of two\n"
"// vectors of types T1 and T2 and common size n, to a vector odata of type T3.\n"
"// ie. we want to produce dot(x,y) in the sense of the given semi-ring.\n"
"\n"
"// Both the grid and block are 1D, so blockDim.x is the # threads in a\n"
"// threadblock, and the # of threadblocks is grid.x\n"
"\n"
"// Let b = blockIdx.x, and let s be blockDim.x.\n"
"// Each threadblock owns s*8 contiguous items in the input data.\n"
"\n"
"// Thus, threadblock b owns g_idata [b*s*8 ... min(n,(b+1)*s*8-1)].  It's job\n"
"// is to reduce this data to a scalar, and write it to g_odata [b].\n"
"\n"
"#include <limits>\n"
"#include <cooperative_groups.h>\n"
"\n"
"using namespace cooperative_groups;\n"
"\n"
"template< typename T3, int tile_sz>\n"
"__inline__ __device__ \n"
"T3 warp_ReduceSum(thread_block_tile<tile_sz> g, T3 val)\n"
"{\n"
"    // Each iteration halves the number of active threads\n"
"    // Each thread adds its partial sum[i] to sum[lane+i]\n"
"    for (int i = g.size() / 2; i > 0; i /= 2)\n"
"    {\n"
"        T3 fold = g.shfl_down( val, i);\n"
"        val = ADD( val, fold );\n"
"    }\n"
"    return val; // note: only thread 0 will return full sum\n"
"}\n"
"\n"
"template<typename T3, int warpSize>\n"
"__inline__ __device__\n"
"T3 block_ReduceSum(thread_block g, T3 val)\n"
"{\n"
"  static __shared__ T3 shared[warpSize]; // Shared mem for 32 partial sums\n"
"  int lane = threadIdx.x % warpSize;\n"
"  int wid = threadIdx.x / warpSize;\n"
"  thread_block_tile<warpSize> tile = tiled_partition<warpSize>(g);\n"
"\n"
"  // Each warp performs partial reduction\n"
"  val = warp_ReduceSum<T3,warpSize>(tile, val);    \n"
"\n"
"  if (lane==0) shared[wid]=val; // Write reduced value to shared memory\n"
"\n"
"  __syncthreads();              // Wait for all partial reductions\n"
"\n"
"  //read from shared memory only if that warp existed\n"
"  val = (threadIdx.x < blockDim.x / warpSize) ? shared[lane] : (T3)MONOID_IDENTITY3;\n"
"\n"
"  \n"
"  if (wid==0) val = warp_ReduceSum<T3,warpSize>(tile,val); //Final reduce within first warp\n"
"\n"
"  return val;\n"
"}\n"
"\n"
"template< typename T1, typename T2, typename T3>\n"
"__global__ void denseDotProduct\n"
"(\n"
"    T1 *g_xdata,     // array of size n, type T1\n"
"    T2 *g_ydata,     // array of size n, type T2\n"
"    T3 *g_odata,       // array of size grid.x, type T3\n"
"    unsigned int n\n"
")\n"
"{\n"
"    // set thread ID\n"
"    unsigned int tid = threadIdx.x ;\n"
"\n"
"    // this threadblock b owns g_idata [block_start ... block_end-1]\n"
"    unsigned long int s = blockDim.x ;\n"
"    unsigned long int b = blockIdx.x ;\n"
"    unsigned long int block_start = b * s * 8 ;\n"
"    unsigned long int block_end   = (b + 1) * s * 8 ;\n"
"\n"
"    /*\n"
"    if (tid == 0)\n"
"    {\n"
"        printf (\"block %d: [%lu ... %ld]\\n\", b, block_start, block_end-1) ;\n"
"    }\n"
"    */\n"
"\n"
"    /*\n"
"    if (tid == 0 && b == 0)\n"
"    {\n"
"        printf (\"type is size %d\\n\", sizeof (T)) ;\n"
"        for (int k = 0 ; k < n ; k++) printf (\"%4d: %g\\n\", k, (double) g_idata [k]) ;\n"
"        printf (\"\\n\") ;\n"
"    }\n"
"    */\n"
"\n"
"    // each thread tid reduces its result into sum \n"
"    T3 sum;\n"
"\n"
"    // nothing to do\n"
"    if (block_start > block_end) { return ; }\n"
"\n"
"    // convert global data pointer to the local pointer of this block\n"
"    T1 *xdata = g_xdata + block_start ;\n"
"    T2 *ydata = g_ydata + block_start ;\n"
"\n"
"    T1 x0, x1, x2, x3, x4, x5, x6, x7 ;\n"
"    T2 y0, y1, y2, y3, y4, y5, y6, y7 ;\n"
"\n"
"    if (block_end <= n)\n"
"    {\n"
"        // unrolling 8\n"
"        x0 = xdata [tid] ;\n"
"        x1 = xdata [tid +     s] ;\n"
"        x2 = xdata [tid + 2 * s] ;\n"
"        x3 = xdata [tid + 3 * s] ;\n"
"        x4 = xdata [tid + 4 * s] ;\n"
"        x5 = xdata [tid + 5 * s] ;\n"
"        x6 = xdata [tid + 6 * s] ;\n"
"        x7 = xdata [tid + 7 * s] ;\n"
"\n"
"        y0 = ydata [tid] ;\n"
"        y1 = ydata [tid +     s] ;\n"
"        y2 = ydata [tid + 2 * s] ;\n"
"        y3 = ydata [tid + 3 * s] ;\n"
"        y4 = ydata [tid + 4 * s] ;\n"
"        y5 = ydata [tid + 5 * s] ;\n"
"        y6 = ydata [tid + 6 * s] ;\n"
"        y7 = ydata [tid + 7 * s] ;\n"
"        /*\n"
"        if (b == 0)\n"
"        {\n"
"            printf (\"block zero: here is tid %2d : %g %g %g %g %g %g %g %g \\n\", tid,\n"
"                (double) x0, (double) x1, (double) x2, (double) x3,\n"
"                (double) x4, (double) x5, (double) x6, (double) x7) ;\n"
"        }\n"
"        */\n"
"\n"
"    }\n"
"    else\n"
"    {\n"
"        // the last block has size less than 8*s\n"
"        #define XDATA(i) ((i < lastblocksize) ? xdata [i] : MONOID_IDENTITY1)\n"
"        #define YDATA(i) ((i < lastblocksize) ? ydata [i] : MONOID_IDENTITY2)\n"
"        int lastblocksize = n - block_start ;\n"
"        x0 = XDATA (tid) ;\n"
"        x1 = XDATA (tid +     s) ;\n"
"        x2 = XDATA (tid + 2 * s) ;\n"
"        x3 = XDATA (tid + 3 * s) ;\n"
"        x4 = XDATA (tid + 4 * s) ;\n"
"        x5 = XDATA (tid + 5 * s) ;\n"
"        x6 = XDATA (tid + 6 * s) ;\n"
"        x7 = XDATA (tid + 7 * s) ;\n"
"\n"
"        y0 = YDATA (tid) ;\n"
"        y1 = YDATA (tid +     s) ;\n"
"        y2 = YDATA (tid + 2 * s) ;\n"
"        y3 = YDATA (tid + 3 * s) ;\n"
"        y4 = YDATA (tid + 4 * s) ;\n"
"        y5 = YDATA (tid + 5 * s) ;\n"
"        y6 = YDATA (tid + 6 * s) ;\n"
"        y7 = YDATA (tid + 7 * s) ;\n"
"    }\n"
"\n"
"    //work [tid] = mul(x0,y0) + mul(x1,y1) + mul(x2,y2) + mul(x3,y3)\n"
"    //               + mul(x4,y4) + mul(x5,y5) + mul(x6,y6)+ mul(x7,y7) ;\n"
"          sum  = ADD( MUL(x0,y0) , ADD( MUL(x1,y1) , ADD( MUL(x2,y2), \n"
"                 ADD( MUL(x3,y3) , ADD( MUL(x4,y4) , ADD( MUL(x5,y5), \n"
"                 ADD( MUL(x6,y6) , MUL(x7,y7)))))))) ;\n"
"\n"
"        /*\n"
"        if (b == 0)\n"
"        {\n"
"            printf (\"block zero: still is tid %2d : %g %g %g %g %g %g %g %g \\n\", tid,\n"
"                (double) x0, (double) x1, (double) x2, (double) x3,\n"
"                (double) x4, (double) x5, (double) x6, (double) x7) ;\n"
"        }\n"
"\n"
"        if (b == 0)\n"
"        {\n"
"            printf (\"block zero: here is tid %d result %g  is %g\\n\",\n"
"            tid, sum,\n"
"            (double) (x0 + x1 + x2 + x3 + x4 + x5 + x6 + x7)) ;\n"
"        }\n"
"        */\n"
"\n"
"    __syncthreads ( ) ;\n"
"\n"
"    //--------------------------------------------------------------------------\n"
"    // reduce per-thread sums to a single scalar\n"
"    //--------------------------------------------------------------------------\n"
"\n"
"    sum = block_ReduceSum<T3, 32>( this_thread_block(), sum); \n"
"\n"
"    // write result for this block to global mem\n"
"    if (tid == 0)\n"
"    {\n"
"        printf (\"final %d : %g\\n\", b, (T3) sum) ;\n"
"        g_odata [b] = sum ;\n"
"    }\n"
"}\n"
"\n"
;

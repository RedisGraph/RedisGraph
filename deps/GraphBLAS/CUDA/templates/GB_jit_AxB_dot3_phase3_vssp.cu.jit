const char* const templates_GB_jit_AxB_dot3_phase3_vssp_cu = "templates/GB_jit_AxB_dot3_phase3_vssp.cu\n"
"//------------------------------------------------------------------------------\n"
"// spGEMM_very_sparse_sparse.cu \n"
"//------------------------------------------------------------------------------\n"
"\n"
"// The spGEM_vssp CUDA kernel produces the semi-ring product of two\n"
"// sparse matrices of types T_A and T_B and common index space size n, to a  \n"
"// output matrix of type T_C. The matrices are sparse, with different numbers\n"
"// of non-zeros and different sparsity patterns. \n"
"// ie. we want to produce C = A'*B in the sense of the given semi-ring.\n"
"\n"
"// This version uses a binary-search algorithm, when the sizes nnzA and nnzB\n"
"// are far apart in size, neither is very spare nor dense, for any size of N.\n"
"\n"
"// Both the grid and block are 1D, so blockDim.x is the # threads in a\n"
"// threadblock, and the # of threadblocks is grid.x\n"
"\n"
"// Let b = blockIdx.x, and let s be blockDim.x. s= 32 with a variable number\n"
"// of active threads = min( min(nzA, nzB), 32) \n"
"\n"
"// Thus, each t in threadblock b owns a part of the set of pairs in the \n"
"// sparse-sparse bucket of work. The job for each pair of vectors is to find \n"
"// the intersection of the index sets Ai and Bi, perform the semi-ring dot \n"
"// product on those items in the intersection, and finally\n"
"// on exit write it to Cx [pair].\n"
"\n"
"//  int64_t start          <- start of vector pairs for this kernel\n"
"//  int64_t end            <- end of vector pairs for this kernel\n"
"//  int64_t *Bucket        <- array of pair indices for all kernels \n"
"//  GrB_Matrix C         <- result matrix \n"
"//  GrB_Matrix M         <- mask matrix\n"
"//  GrB_Matrix A         <- input matrix A\n"
"//  GrB_Matrix B         <- input matrix B\n"
"\n"
"#include <limits>\n"
"#include <cstdint>\n"
"#include <cooperative_groups.h>\n"
"#include \"mySemiRing.h\"\n"
"#include \"matrix.h\"\n"
"\n"
"// Using tile size fixed at compile time, we don't need shared memory\n"
"#define tile_sz 32 \n"
"\n"
"using namespace cooperative_groups;\n"
"\n"
"template< typename T, int warpSize >\n"
"__device__ T reduce_sum(thread_block_tile<warpSize> g, T val)\n"
"{\n"
"    // Each iteration halves the number of active threads\n"
"    // Each thread adds its partial sum[i] to sum[lane+i]\n"
"    for (int i = g.size() / 2; i > 0; i /= 2)\n"
"    {\n"
"        val += g.shfl_down(val,i) ;\n"
"    }\n"
"    return val; // note: only thread 0 will return full sum\n"
"}\n"
"\n"
"#define intersects_per_thread 8\n"
"\n"
"template< typename T_C, typename T_A, typename T_B, typename T_X, typename T_Y, typename T_Z>\n"
"__global__ void AxB_dot3_phase3_vssp\n"
"(\n"
"    int64_t start,\n"
"    int64_t end,\n"
"    int64_t *Bucket,\n"
"    GrB_Matrix C,\n"
"    GrB_Matrix M,\n"
"    GrB_Matrix A,\n"
"    GrB_Matrix B,\n"
"    int sz\n"
")\n"
"{\n"
"   // Typed pointers to access data in A,B,C\n"
"   T_A *Ax = (T_A*)A->x;\n"
"   T_B *Bx = (T_B*)B->x;\n"
"   T_C *Cx = (T_C*)C->x;\n"
"   int64_t *Ci = C->i;\n"
"   int64_t *Mi = M->i;\n"
"   int64_t *Ai = A->i;\n"
"   int64_t *Bi = B->i;\n"
"   int64_t *Ap = A->p;\n"
"   int64_t *Bp = B->p;\n"
"\n"
"   // sz = expected non-zeros per dot \n"
"   int m = 256/sz;\n"
"   int nvecs = end - start;\n"
"   int dpt = nvecs/(gridDim.x*32);\n"
"   \n"
"   int dots = (nvecs +dpt -1)/dpt; \n"
"\n"
"   // zombie count\n"
"   int zc = 0;\n"
"   int64_t pair_id, im;\n"
"\n"
"   // set thread ID\n"
"   unsigned int tid_global = threadIdx.x+ blockDim.x* blockIdx.x;\n"
"   unsigned int tid = threadIdx.x;\n"
"\n"
"   unsigned long int b = blockIdx.x ;\n"
"\n"
"   // Main loop over pairs \n"
"   for (pair_id = start+ tid_global, im = 0; \n"
"        pair_id < end && im < m;  \n"
"        pair_id += gridDim.x*blockDim.x, ++im){\n"
"\n"
"        int64_t i = Mi[pair_id];\n"
"        int64_t j = Ci[pair_id] >> 4;\n"
"\n"
"        int64_t pA      = Ap[i];\n"
"        int64_t pA_end  = Ap[i+1];\n"
"        int64_t nnzA = pA_end - pA;\n"
"\n"
"        int64_t pB      = B->p[j]; \n"
"        int64_t pB_end  = B->p[j+1]; \n"
"        int64_t nnzB = pB_end - pB;\n"
"\n"
"        //Search for each nonzero in the smaller vector to find intersection \n"
"        bool cij_exists = false;\n"
"\n"
"        T_A aki;\n"
"        T_B bkj;\n"
"        T_Z cij;\n"
"\n"
"        if (nnzA <= nnzB) {\n"
"            //----------------------------------------------------------------------\n"
"            // A(:,i) is very sparse compared to B(:,j)\n"
"            //----------------------------------------------------------------------\n"
"\n"
"            while (pA < pA_end && pB < pB_end)\n"
"            {\n"
"                int64_t ia = Ai [pA] ;\n"
"                int64_t ib = Bi [pB] ;\n"
"                if (ia < ib)\n"
"                { \n"
"                    // A(ia,i) appears before B(ib,j)\n"
"                    pA++ ;\n"
"                }\n"
"                else if (ib < ia)\n"
"                { \n"
"                    // B(ib,j) appears before A(ia,i)\n"
"                    // discard all entries B(ib:ia-1,j)\n"
"                    int64_t pleft = pB + 1 ;\n"
"                    int64_t pright = pB_end - 1 ;\n"
"                    GB_TRIM_BINARY_SEARCH (ia, Bi, pleft, pright) ;\n"
"                    //ASSERT (pleft > pB) ;\n"
"                    pB = pleft ;\n"
"                }\n"
"                else // ia == ib == k\n"
"                { \n"
"                    // A(k,i) and B(k,j) are the next entries to merge\n"
"                    #if defined ( GB_PHASE_1_OF_2 )\n"
"                    cij_exists = true ;\n"
"                    break ;\n"
"                    #else\n"
"                    GB_DOT_MERGE ;\n"
"                    //GB_DOT_TERMINAL (cij) ;         // break if cij == terminal\n"
"                    pA++ ;\n"
"                    pB++ ;\n"
"                    #endif\n"
"                }\n"
"            }\n"
"        }\n"
"        else {\n"
"            //----------------------------------------------------------------------\n"
"            // B(:,j) is very sparse compared to A(:,i)\n"
"            //----------------------------------------------------------------------\n"
"\n"
"            while (pA < pA_end && pB < pB_end)\n"
"            {\n"
"                int64_t ia = Ai [pA] ;\n"
"                int64_t ib = Bi [pB] ;\n"
"                if (ia < ib)\n"
"                { \n"
"                    // A(ia,i) appears before B(ib,j)\n"
"                    // discard all entries A(ia:ib-1,i)\n"
"                    int64_t pleft = pA + 1 ;\n"
"                    int64_t pright = pA_end - 1 ;\n"
"                    GB_TRIM_BINARY_SEARCH (ib, Ai, pleft, pright) ;\n"
"                    //ASSERT (pleft > pA) ;\n"
"                    pA = pleft ;\n"
"                }\n"
"                else if (ib < ia)\n"
"                { \n"
"                    // B(ib,j) appears before A(ia,i)\n"
"                    pB++ ;\n"
"                }\n"
"                else // ia == ib == k\n"
"                { \n"
"                    // A(k,i) and B(k,j) are the next entries to merge\n"
"                    #if defined ( GB_PHASE_1_OF_2 )\n"
"                    cij_exists = true ;\n"
"                    break ;\n"
"                    #else\n"
"                    GB_DOT_MERGE ;\n"
"                    //GB_DOT_TERMINAL (cij) ;         // break if cij == terminal\n"
"                    pA++ ;\n"
"                    pB++ ;\n"
"                    #endif\n"
"                }\n"
"            }\n"
"\n"
"        }\n"
"        if ( cij_exists){\n"
"           GB_PUTC ( Ci[pair_id]=i ) ;\n"
"           GB_PUTC ( Cx[pair_id]=(T_C)cij ) ;\n"
"        }\n"
"        else {\n"
"           zc++; \n"
"           //printf(\" %lld, %lld is zombie %d!\\n\",i,j,zc);\n"
"           GB_PUTC( Ci[pair_id] = GB_FLIP( i ) ) ;\n"
"        }\n"
"\n"
"\n"
"    }\n"
"\n"
"    //--------------------------------------------------------------------------\n"
"    // reduce sum per-thread values to a single scalar\n"
"    //--------------------------------------------------------------------------\n"
"    thread_block_tile<tile_sz> tile = tiled_partition<tile_sz>( this_thread_block());\n"
"    zc = reduce_sum<int,tile_sz>(tile, zc);\n"
"\n"
"    if( threadIdx.x ==0) {\n"
"      //printf(\"warp %d zombie count = %d\\n\", blockIdx.x, zc);\n"
"      atomicAdd( (unsigned long long int*)&(C->zombie_count), (unsigned long long int)zc);\n"
"      //printf(\" Czombie = %lld\\n\",C->zombie_count);\n"
"    }\n"
"\n"
"}\n"
"\n"
;

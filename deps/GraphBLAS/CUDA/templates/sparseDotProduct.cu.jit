const char* const templates_sparseDotProduct_cu = "templates/sparseDotProduct.cu\n"
"//------------------------------------------------------------------------------\n"
"// sparseDotProduct_merge_path.cu \n"
"//------------------------------------------------------------------------------\n"
"\n"
"// The sparseDotProduct CUDA kernel produces the semi-ring dot product of two\n"
"// sparse vectors of types T1 and T2 and common index space size n, to a scalar \n"
"// odata of type T3. The vectors are sparse, with different numbers of non-zeros.\n"
"// ie. we want to produce dot(x,y) in the sense of the given semi-ring.\n"
"\n"
"// This version uses a merge-path algorithm, when the sizes g_xnz and g_ynz are \n"
"// relatively close in size, but for any size of N.\n"
"\n"
"// Both the grid and block are 1D, so blockDim.x is the # threads in a\n"
"// threadblock, and the # of threadblocks is grid.x\n"
"\n"
"// Let b = blockIdx.x, and let s be blockDim.x. s= 32 with a variable number\n"
"// of active threads = min( min(g_xnz, g_ynz), 32) \n"
"\n"
"// Thus, threadblock b owns a part of the index set spanned by g_xi and g_yi.  Its job\n"
"// is to find the intersection of the index sets g_xi and g_yi, perform the semi-ring dot\n"
"// product on those items in the intersection, and finally reduce this data to a scalar, \n"
"// on exit write it to g_odata [b].\n"
"\n"
"#include <limits>\n"
"#include <cooperative_groups.h>\n"
"\n"
"using namespace cooperative_groups;\n"
"\n"
"template< typename T, int tile_sz>\n"
"__device__ T reduce_sum(thread_block_tile<tile_sz> g, T val)\n"
"{\n"
"    // Each iteration halves the number of active threads\n"
"    // Each thread adds its partial sum[i] to sum[lane+i]\n"
"    for (int i = g.size() / 2; i > 0; i /= 2)\n"
"    {\n"
"        val = ADD( val, g.shfl_down(val,i) );\n"
"        //if (g.thread_rank() ==0)\n"
"        //    printf(\"in reduce_sum i=%i val = %f\\n\", i, val);\n"
"    }\n"
"    return val; // note: only thread 0 will return full sum\n"
"}\n"
"\n"
"#define INTMIN( A, B) ( (A) < (B) ) ?  (A) : (B)\n"
"#define INTMAX( A, B) ( (A) > (B) ) ?  (A) : (B)\n"
"#define intersects_per_thread 4\n"
"\n"
"template< typename T1, typename T2, typename T3>\n"
"__global__ void sparseDotProduct\n"
"(\n"
"    unsigned int g_xnz,       // Number of non-zeros in x\n"
"    unsigned int *g_xi,       // Non-zero indices in x, size xnz\n"
"    T1 *g_xdata,              // array of size xnz, type T1\n"
"    unsigned int g_ynz,       // Number of non-zeros in y\n"
"    unsigned int *g_yi,       // Non-zero indices in y, size ynz\n"
"    T2 *g_ydata,              // array of size ynz, type T2\n"
"    T3 *g_odata               // array of size grid.x, type T3\n"
")\n"
"{\n"
"    // set thread ID\n"
"    unsigned int tid_global = threadIdx.x+ blockDim.x* blockIdx.x;\n"
"    unsigned int tid = threadIdx.x;\n"
"\n"
"    unsigned long int b = blockIdx.x ;\n"
"\n"
"    // total items to be inspected\n"
"    unsigned int nxy = (g_xnz + g_ynz);\n"
"\n"
"    //largest possible number of intersections is the smaller nz\n"
"    unsigned int n_intersect = INTMIN( g_xnz, g_ynz); \n"
"\n"
"    //we want more than one intersection per thread\n"
"    unsigned int parts = (n_intersect+ intersects_per_thread -1)/ intersects_per_thread; \n"
"\n"
"    unsigned int work_per_thread = (nxy +parts -1)/parts;\n"
"    unsigned int diag = INTMIN( work_per_thread*tid_global, nxy);\n"
"    unsigned int diag_end = INTMIN( diag + work_per_thread, nxy);\n"
"    //printf(\" thd%d parts = %u wpt = %u diag, diag_end  = %u,%u\\n\",tid, parts, work_per_thread, diag, diag_end); \n"
"\n"
"   unsigned int x_min = INTMAX( (int)(diag - g_ynz), 0);\n"
"   unsigned int x_max = INTMIN( diag, g_xnz);\n"
"\n"
"   //printf(\"start thd%u x_min = %u x_max = %u\\n\", tid_global, x_min,x_max);\n"
"   while ( x_min < x_max) { //binary search for correct diag break\n"
"      unsigned int pivot = (x_min +x_max)/2;\n"
"      if ( g_xi[pivot] < g_yi[ diag -pivot -1]) {\n"
"         x_min = pivot +1;\n"
"      }\n"
"      else {\n"
"         x_max = pivot;\n"
"      }\n"
"   }\n"
"   int xcoord = x_min;\n"
"   int ycoord = diag -x_min -1;\n"
"   if (( diag > 0) &&(diag < (g_xnz+g_ynz)) && (g_xi[xcoord] == g_yi[ycoord]) ) { \n"
"       diag--; //adjust for intersection incrementing both pointers \n"
"   }\n"
"   // two start points are known now\n"
"   int x_start = xcoord;\n"
"   int y_start = diag -xcoord; \n"
"\n"
"   //if (x_start != y_start)\n"
"   //   printf(\"start thd%u  xs,ys = %i,%i\\n\", tid_global, x_start, y_start);\n"
"\n"
"   x_min = INTMAX( (int)(diag_end - g_ynz), 0);\n"
"   x_max = INTMIN( diag_end, g_xnz);\n"
"\n"
"   while ( x_min < x_max) {\n"
"      unsigned int pivot = (x_min +x_max)/2;\n"
"      //printf(\"thd%u pre_sw piv=%u diag_e = %u  xmin,xmax=%u,%u\\n\", tid_global, pivot, diag_end,x_min, x_max);\n"
"      if ( g_xi[pivot] < g_yi[ diag_end -pivot -1]) {\n"
"         x_min = pivot +1;\n"
"      }\n"
"      else {\n"
"         x_max = pivot;\n"
"      }\n"
"      //printf(\"thd%u piv=%u xmin,xmax = %u,%u\\n\", tid_global, pivot, x_min, x_max);\n"
"   }\n"
"   xcoord = x_min;\n"
"   ycoord = diag_end -x_min -1;\n"
"   if ( (diag_end < (g_xnz+g_ynz)) && (g_xi[xcoord] == g_yi[ycoord]) ) { \n"
"       diag--; //adjust for intersection incrementing both pointers  \n"
"   }\n"
"   // two end points are known now\n"
"   int x_end = xcoord; \n"
"   int y_end = diag_end - xcoord; \n"
"\n"
"   /* \n"
"   if (tid == 0 && b == 0) {\n"
"        printf (\"type1 is size %d\\n\", sizeof (T1)) ;\n"
"        for (int k = 0 ; k < g_xnz ; k++) printf (\"%4d: %g,\", k, (T1) g_xdata [k]) ;\n"
"        printf (\"\\n\") ;\n"
"        printf (\"type2 is size %d\\n\", sizeof (T2)) ;\n"
"        for (int k = 0 ; k < g_ynz ; k++) printf (\"%4d: %g,\", k, (T2) g_ydata [k]) ;\n"
"        printf (\"\\n\") ;\n"
"    }\n"
"    __syncthreads();\n"
"    */\n"
"\n"
"    T3 sum = (T3) 0;\n"
"    //printf(\" thd%u has init value %f\\n\",tid, sum);\n"
"\n"
"    // nothing to do\n"
"    if ( (x_start >= x_end) || (y_start >= y_end) ) { return ; }\n"
"\n"
"    //merge-path dot product\n"
"    int k = x_start;\n"
"    int l = y_start;\n"
"    while ( k < x_end && l < y_end )\n"
"    {\n"
"       if      ( g_xi[k] < g_yi[l] ) k += 1;\n"
"       else if ( g_xi[k] > g_yi[l] ) l += 1; \n"
"       else {\n"
"          //printf(\"  thd%d ix at %u \\n\",tid_global,g_xi[k]);\n"
"          //printf(\"   sum += %f * %f \\n\",tid,g_xdata[k],g_ydata[l]);\n"
"          //sum = ADD( sum, MUL( g_xdata[k], g_ydata[l]));\n"
"          MULADD( sum, g_xdata[k], g_ydata[l]);\n"
"          //printf(\" thd%u work value = %f\\n\",tid_global, sum);\n"
"          k+= 1;\n"
"          l+= 1;\n"
"       }\n"
"\n"
"    }\n"
"\n"
"    __syncthreads ( ) ;\n"
"    /*\n"
"    if (1)\n"
"    {\n"
"        printf (\"thd%u done with intersect and multiply, val = %f\\n\",tid_global, sum) ;\n"
"    }\n"
"    __syncthreads ( ) ;\n"
"    */\n"
"\n"
"    //--------------------------------------------------------------------------\n"
"    // reduce sum per-thread values to a single scalar\n"
"    //--------------------------------------------------------------------------\n"
"    // Using tile size fixed at compile time, we don't need shared memory\n"
"    #define tile_sz 32 \n"
"    thread_block_tile<tile_sz> tile = tiled_partition<tile_sz>( this_thread_block());\n"
"    T3 block_sum = reduce_sum<T3,tile_sz>(tile, sum);\n"
"\n"
"    // write result for this block to global mem\n"
"    if (tid == 0)\n"
"    {\n"
"        printf (\"final %d : %g\\n\", b,  block_sum) ;\n"
"        g_odata [b] = block_sum ;\n"
"    }\n"
"}\n"
"\n"
;

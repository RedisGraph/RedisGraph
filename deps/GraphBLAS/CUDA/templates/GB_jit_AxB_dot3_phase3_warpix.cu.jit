const char* const templates_GB_jit_AxB_dot3_phase3_warpix_cu = "templates/GB_jit_AxB_dot3_phase3_warpix.cu\n"
"//------------------------------------------------------------------------------\n"
"// AxB_dot3_phase3_warpix.cu \n"
"//------------------------------------------------------------------------------\n"
"\n"
"// This CUDA kernel produces the semi-ring product of two\n"
"// sparse matrices of types T_A and T_B and common index space size n, to a  \n"
"// output matrix of type T_C. The matrices are sparse, with different numbers\n"
"// of non-zeros and different sparsity patterns. \n"
"// ie. we want to produce C = A'*B in the sense of the given semi-ring.\n"
"\n"
"// This version uses a merge-path algorithm, when the sizes nnzA and nnzB are \n"
"// relatively close in size, neither is very spare nor dense, for any size of N.\n"
"// Handles arbitrary sparsity patterns with guaranteed load balance.\n"
"\n"
"// Both the grid and block are 1D, so blockDim.x is the # threads in a\n"
"// threadblock, and the # of threadblocks is grid.x\n"
"\n"
"// Let b = blockIdx.x, and let s be blockDim.x. s= 32 with a variable number\n"
"// of active threads = min( min(g_xnz, g_ynz), 32) \n"
"\n"
"// Thus, threadblock b owns a part of the index set spanned by g_xi and g_yi.  Its job\n"
"// is to find the intersection of the index sets g_xi and g_yi, perform the semi-ring dot\n"
"// product on those items in the intersection, and finally reduce this data to a scalar, \n"
"// on exit write it to g_odata [b].\n"
"\n"
"//  int64_t start          <- start of vector pairs for this kernel\n"
"//  int64_t end            <- end of vector pairs for this kernel\n"
"//  int64_t *Bucket        <- array of pair indices for all kernels \n"
"//  matrix<T_C> *C         <- result matrix \n"
"//  matrix<T_M> *M         <- mask matrix\n"
"//  matrix<T_A> *A         <- input matrix A\n"
"//  matrix<T_B> *B         <- input matrix B\n"
"#define GB_KERNEL\n"
"#include <limits>\n"
"#include <cstdint>\n"
"#include \"matrix.h\"\n"
"#include <cooperative_groups.h>\n"
"\n"
"// Using tile size fixed at compile time, we don't need shared memory\n"
"#define tile_sz 32 \n"
"\n"
"using namespace cooperative_groups;\n"
"\n"
"template< typename T, int warp_sz>\n"
"__device__ __inline__ \n"
"T GB_reduce_sum(thread_block_tile<warp_sz> g, T val)\n"
"{\n"
"    // Each iteration halves the number of active threads\n"
"    // Each thread adds its partial sum[i] to sum[lane+i]\n"
"    for (int i = g.size() / 2; i > 0; i /= 2)\n"
"    {\n"
"        T next = g.shfl_down( val, i);\n"
"        val = GB_ADD( val, next ) ;\n"
"    }\n"
"    return val;\n"
"}\n"
"\n"
"template< typename T, int warp_sz>\n"
"__device__ __inline__ \n"
"T reduce_plus(thread_block_tile<warp_sz> g, T val)\n"
"{\n"
"    // Each iteration halves the number of active threads\n"
"    // Each thread adds its partial sum[i] to sum[lane+i]\n"
"    for (int i = g.size() / 2; i > 0; i /= 2)\n"
"    {\n"
"        val += g.shfl_down( val, i) ;\n"
"    }\n"
"    return val; // note: only thread 0 will return full sum and flag value\n"
"}\n"
"\n"
"#define intersects_per_thread 8\n"
"\n"
"template< typename T_C, typename T_A, typename T_B, typename T_X, typename T_Y, typename T_Z>  \n"
"__global__ void AxB_dot3_phase3_warpix\n"
"(\n"
"    int64_t start,\n"
"    int64_t end,\n"
"    int64_t *__restrict__ Bucket,\n"
"    GrB_Matrix C,\n"
"    GrB_Matrix M,\n"
"    GrB_Matrix A,\n"
"    GrB_Matrix B,\n"
"    int sz\n"
")\n"
"{\n"
"\n"
"    T_A *__restrict__ Ax = (T_A*)A->x;\n"
"    T_B *__restrict__ Bx = (T_B*)B->x;\n"
"    T_C *__restrict__ Cx = (T_C*)C->x;\n"
"    int64_t *__restrict__ Ci = C->i;\n"
"    int64_t *__restrict__ Mi = M->i;\n"
"    int64_t *__restrict__ Mp = M->p;\n"
"    int64_t *__restrict__ Ai = A->i;\n"
"    int64_t *__restrict__ Bi = B->i;\n"
"    int64_t *__restrict__ Ap = A->p;\n"
"    int64_t *__restrict__ Bp = B->p;\n"
"\n"
"    int64_t mnvec = M->nvec;\n"
"\n"
"    // zombie count\n"
"    int zc;\n"
"\n"
"    int64_t pair_id;\n"
"\n"
"    // set thread ID\n"
"    int tid_global = threadIdx.x+ blockDim.x* blockIdx.x;\n"
"    int tid = threadIdx.x;\n"
"    int b = blockIdx.x ;\n"
"\n"
"    // total items to be inspected\n"
"    int64_t nnzA = 0;\n"
"    int64_t nnzB = 0;\n"
"\n"
"    thread_block_tile<tile_sz> tile = tiled_partition<tile_sz>( this_thread_block());\n"
"\n"
"    //int parts = gridDim.x; //Each warp is a part\n"
"\n"
"    //Find our part of the work bucket\n"
"    int64_t pfirst, plast, kfirst, klast ;\n"
"    GB_PARTITION (pfirst, plast, end-start, b, gridDim.x ) ;\n"
"    /* \n"
"    if( tid ==0 ) {\n"
"       printf(\"block%d is alive, pf,pl=%ld,%ld \\n\", b, pfirst, plast);\n"
"    }\n"
"    __syncthreads();\n"
"    */\n"
"    \n"
"    \n"
"    __shared__ int64_t As[256];\n"
"    __shared__ int64_t Bs[256];\n"
"    __shared__ T_A Axs[256]; \n"
"    __shared__ T_B Bxs[256]; \n"
"\n"
"   /* \n"
"    int Bpl[9]; // local offsets into shared for multiple vectors of B\n"
"    int shr_vec[8] ; //columns of B we see in this task\n"
"\n"
"    pair_id = Bucket[pfirst];\n"
"    int64_t i = Mi[pair_id] ;\n"
"    int vecs = 1 ;\n"
"    int last_vec = i;\n"
"    shr_vec[0] = i;\n"
"    for (int id =1; id< plast-pfirst; id++)\n"
"    {\n"
"         pair_id = Bucket[pfirst+id];\n"
"         i = Mi[pair_id];\n"
"         if (i == last_vec) continue;\n"
"         vecs++;\n"
"         shr_vec[vecs] = i;\n"
"         last_vec = i;\n"
"    }\n"
"    int all_loaded = 0;\n"
"\n"
"    Bpl[0] = 0;\n"
"    for ( int k = 0; k < vecs; k++)\n"
"    {   \n"
"        int64_t pA       = Ap[ shr_vec[k] ]; \n"
"        int64_t pA_end   = Ap[ shr_vec[k] +1]; \n"
"        nnzA = pA_end - pA;\n"
"        Bpl[k+1] = Bpl[k] + nnzA;\n"
"        for (int i = tid ; i < nnzA; i+= blockDim.x)\n"
"        {\n"
"           As[ Bpl[k] +i ] = Ai[ pA + i ] ; \n"
"        }\n"
"        __syncthreads();\n"
"    }\n"
"\n"
"    //pre-load columns of B, which will be reused, to shared memory\n"
"    //Due to loading a contigious block with stride 1 this is fast\n"
"        \n"
"    all_loaded = (Bpl[vecs] < 256 );\n"
"    if( tid == 0 ) {\n"
"       printf(\"block%d loaded %d vals from B, vecs=%d, all_loaded=%d\\n\",\n"
"                 b, Bpl[vecs], vecs, all_loaded );\n"
"    }\n"
"    __syncthreads();\n"
"\n"
"\n"
"    // reset counter\n"
"    */\n"
"    // Main loop over pairs \n"
"    for (int id = start + pfirst; // loop on pairs \n"
"         id < start+ plast;  \n"
"         id ++ )\n"
"    {\n"
"         int64_t pair_id = Bucket[id];\n"
"          \n"
"         int64_t i = Mi[pair_id];\n"
"         int64_t j = Ci[pair_id] >> 4;\n"
"\n"
"         int64_t pA       = Ap[i];\n"
"         int64_t pA_end   = Ap[i+1];\n"
"         nnzA = pA_end - pA;\n"
"\n"
"         int64_t pB       = Bp[j]; \n"
"         int64_t pB_end   = Bp[j+1]; \n"
"         nnzB = pB_end - pB;\n"
"\n"
"         zc = 0 ;\n"
"         int j_last = -1 ;\n"
"         \n"
"         \n"
"    // No search, this warp does all the work\n"
"\n"
"    int tx_start = pA;\n"
"    int tx_end   = pA_end;\n"
"    int ty_start = pB;\n"
"    int ty_end   = pB_end;\n"
"\n"
"    for ( int i = tid; i < nnzA ; i+= blockDim.x)\n"
"    {\n"
"       As [i] = Ai[ pA + i];\n"
"       Axs[i] = Ax[ pA + i];\n"
"    }\n"
"    __syncthreads();\n"
"\n"
"    if ( j != j_last) { \n"
"        for ( int i = tid; i < nnzB ; i+= blockDim.x)\n"
"        {\n"
"           Bs [i] = Bi[ pB + i];\n"
"           Bxs[i] = Bx[ pB + i];\n"
"        }\n"
"        __syncthreads();\n"
"        j_last = j;\n"
"    }\n"
"    \n"
"\n"
"    /*     \n"
"    if ( tid==0 ) {\n"
"      //printf(\"block %d dot %lld i,j= %lld,%lld\\n\", blockIdx.x, pair_id, i, j);\n"
"      printf(\"block%d dot %ld(i,j)=(%ld,%ld) xs,xe= %d,%d ys,ye = %d,%d \\n\", \n"
"               b, pair_id, i, j, tx_start,tx_end, ty_start, ty_end);\n"
"      //for(int a = 0; a < nnzA; a++) printf(\" As[%d]:%ld \",a, As[j]);\n"
"    }\n"
"    tile.sync();\n"
"    */\n"
"    \n"
"    \n"
"\n"
"    // Warp intersection: balanced by design, no idle threads. \n"
"    // Each 32 thread warp will handle 32 comparisons per loop.\n"
"    // Either A or B takes stride 4, other takes stride 8\n"
"    // For this version A strides 4, B strides 8\n"
"    T_A aki;\n"
"    T_B bkj;\n"
"    T_Z cij = GB_IDENTITY ;\n"
"    int Astride = nnzA > nnzB ? 8 : 4;\n"
"    int Ashift  = nnzA > nnzB ? 3 : 2;\n"
"    int Amask   = nnzA > nnzB ? 7 : 3;\n"
"    int Bstride = nnzB >= nnzA ? 8 : 4;\n"
"    //printf(\" Astride = %d, Bstride = %d\\n\", Astride, Bstride);\n"
"\n"
"    // TODO PLUS_PAIR_INT64, FP32, FP64: no need for cij_exists.\n"
"    // just check if cij > 0\n"
"\n"
"    int cij_exists  = 0 ;\n"
"\n"
"    //Warp intersection dot product\n"
"    int bitty_row = tid &  Amask ;\n"
"    int bitty_col = tid >> Ashift ;\n"
"\n"
"    int k = tx_start + bitty_row ;\n"
"    int l = ty_start + bitty_col ;\n"
"\n"
"    //Ai[k] = As[ k -pA ];  for lookup\n"
"    //Bi[l] = Bs[ l -pB ]; \n"
"\n"
"\n"
"    int inc_k,inc_l;\n"
"\n"
"    int active = ( ( k < tx_end) && (l < ty_end ) );\n"
"       \n"
"    /*    \n"
"    printf(\"block%d tid%d  Ai,As=%ld,%ld Bi,Bs=%ld,%ld  k,l =%d,%d active:%d\\n\",\n"
"                    b,tid, Ai[k], As[k -pA], Bi[l], Bs[l -pB],\n"
"                    k, l,  active );\n"
"    */\n"
"                    \n"
"    \n"
"    while ( tile.any(active) )\n"
"    {\n"
"       inc_k = 0;\n"
"       inc_l = 0;\n"
"       int kp = k-pA;\n"
"       int lp = l-pB;\n"
"       if ( active )\n"
"       { \n"
"          coalesced_group g = coalesced_threads();\n"
"          if ( g.thread_rank() == g.size()-1)\n"
"          {\n"
"             inc_k = ( As[kp] <= Bs[lp] ) ;\n"
"             inc_l = ( Bs[lp] <= As[kp] ) ;\n"
"             // printf(\"block%d tid%d inc_k= %d inc_l = %d\\n\",b, tid, inc_k, inc_l );\n"
"          }\n"
"          //tile.sync();\n"
"\n"
"          if ( As [kp] == Bs [lp] )\n"
"          {\n"
"              //Axs[kp] = Ax[k];\n"
"              //Bxs[lp] = Bx[l];\n"
"\n"
"              GB_GETA ( aki=(T_Z)Axs[kp] ) ;\n"
"              GB_GETB ( bkj=(T_Z)Bxs[lp] ) ;\n"
"              if (cij_exists)\n"
"              {\n"
"                T_Z t = GB_MULT( (T_Z) aki, (T_Z) bkj);\n"
"                GB_ADD_F( cij, t ) ;\n"
"                //printf(\"block%d  thd%d ix at %ld(%ld)  cij += %d * %d\\n\",b, tid, Ai[k], As[kp], aki, bkj);\n"
"              }\n"
"              else\n"
"              {\n"
"                cij_exists = 1 ;\n"
"                cij = GB_MULT ( (T_Z) aki, (T_Z) bkj) ;\n"
"                //printf(\"  thd%d ix at %ld(%ld)  cij = %d * %d \\n\", tid, Ai[k], Ais[kp], aki, bkj);\n"
"              }\n"
"          }\n"
"          // TODO check terminal condition\n"
"          //printf(\" block%u work value = %d, exists = %d\\n\", b, cij, cij_exists);\n"
"          //printf(\"block%d tid%d k,l = %d,%d Ai,Bi = %ld,%ld \\n\", b, tid, k, l, Ai[k], Bi[l] );\n"
"       }\n"
"       //tile.sync();\n"
"       //inc_k = tile.shfl_down( inc_k, 31-tid);\n"
"       if( tile.any(inc_k) ) {\n"
"          k =1+ tile.shfl_down(k,31-tid) + bitty_row ; // tid%Astride;\n"
"          //Ais [k-pA] = As[k-pA];\n"
"          //Axs [bitty_row] = Ax[k];\n"
"       }\n"
"       if( tile.any(inc_l) ) {\n"
"          l =1+ tile.shfl_down(l,31-tid) + bitty_col ; // tid/Astride;\n"
"          //Bis [l-pB] = Bs[l-pB];\n"
"          //Bxs [bitty_col] = Bx[l];\n"
"       }\n"
"       active = ( ( k < tx_end) && (l < ty_end ) );\n"
"       //printf(\"block%d tid = %d k = %d l= %d active=%d\\n\", b, tid, k, l,active);\n"
"    }\n"
"    tile.sync();\n"
"\n"
"    //--------------------------------------------------------------------------\n"
"    // reduce sum per-thread values to a single scalar, get OR of flag\n"
"    //--------------------------------------------------------------------------\n"
"\n"
"    // Do vote here for control.\n"
"    cij_exists  = tile.any( cij_exists);\n"
"    tile.sync();\n"
"\n"
"    if (cij_exists)\n"
"    {\n"
"       cij = GB_reduce_sum<T_Z, tile_sz>( tile, cij );\n"
"    }\n"
"    tile.sync();\n"
"    \n"
"\n"
"    // Atomic write result for this block to global mem\n"
"    if (tid == 0)\n"
"    {\n"
"        //printf (\"final %d : %d exists = %d\\n\", b,  cij, cij_exists) ;\n"
"        if (cij_exists)\n"
"        {\n"
"           //printf(\"block%d i,j =%ld,%ld cij = %d\\n\",b, i, j, cij);\n"
"           GB_PUTC( Cx[pair_id] = (T_C) cij ) ;\n"
"           GB_PUTC ( Ci[pair_id] = i ) ;\n"
"           \n"
"        }\n"
"        else\n"
"        {\n"
"            //printf(\" dot %d is a zombie\\n\", pair_id);\n"
"            zc++;\n"
"            GB_PUTC ( Ci[pair_id] = GB_FLIP (i) ) ;\n"
"        }\n"
"    \n"
"    //__syncthreads(); \n"
"  \n"
"\n"
"       if( zc > 0)\n"
"       {\n"
"          //printf(\"warp %d zombie count = %d\\n\", blockIdx.x, zc);\n"
"          atomicAdd( (unsigned long long int*)&(C->nzombies), (unsigned long long int)zc);\n"
"          //printf(\"blk:%d Czombie = %lld\\n\",blockIdx.x,C->zombies);\n"
"       }\n"
"\n"
"    }\n"
"    tile.sync();\n"
"    /*\n"
"    */\n"
"  }\n"
"}\n"
"\n"
;

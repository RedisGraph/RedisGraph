const char* const templates_GB_jit_AxB_dot3_phase3_warpix_cu = "templates/GB_jit_AxB_dot3_phase3_warpix.cu\n"
"//------------------------------------------------------------------------------\n"
"// AxB_dot3_phase3_warpix.cu \n"
"//------------------------------------------------------------------------------\n"
"\n"
"// This CUDA kernel produces the semi-ring product of two\n"
"// sparse matrices of types T_A and T_B and common index space size n, to a  \n"
"// output matrix of type T_C. The matrices are sparse, with different numbers\n"
"// of non-zeros and different sparsity patterns. \n"
"// ie. we want to produce C = A'*B in the sense of the given semi-ring.\n"
"\n"
"// This version uses a merge-path algorithm, when the sizes nnzA and nnzB are \n"
"// relatively close in size, neither is very spare nor dense, for any size of N.\n"
"// Handles arbitrary sparsity patterns with guaranteed load balance.\n"
"\n"
"// Both the grid and block are 1D, so blockDim.x is the # threads in a\n"
"// threadblock, and the # of threadblocks is grid.x\n"
"\n"
"// Let b = blockIdx.x, and let s be blockDim.x. s= 32 with a variable number\n"
"// of active threads = min( min(g_xnz, g_ynz), 32) \n"
"\n"
"// Thus, threadblock b owns a part of the index set spanned by g_xi and g_yi.  Its job\n"
"// is to find the intersection of the index sets g_xi and g_yi, perform the semi-ring dot\n"
"// product on those items in the intersection, and finally reduce this data to a scalar, \n"
"// on exit write it to g_odata [b].\n"
"\n"
"//  int64_t start          <- start of vector pairs for this kernel\n"
"//  int64_t end            <- end of vector pairs for this kernel\n"
"//  int64_t *Bucket        <- array of pair indices for all kernels \n"
"//  matrix<T_C> *C         <- result matrix \n"
"//  matrix<T_M> *M         <- mask matrix\n"
"//  matrix<T_A> *A         <- input matrix A\n"
"//  matrix<T_B> *B         <- input matrix B\n"
"#include <limits>\n"
"#include <cstdint>\n"
"#include <cooperative_groups.h>\n"
"#include \"mySemiRing.h\"\n"
"#include \"matrix.h\"\n"
"\n"
"// Using tile size fixed at compile time, we don't need shared memory\n"
"#define tile_sz 32 \n"
"\n"
"using namespace cooperative_groups;\n"
"\n"
"template< typename T, int warp_sz>\n"
"__device__ __inline__ \n"
"T GB_reduce_sum(thread_block_tile<warp_sz> g, T val)\n"
"{\n"
"    // Each iteration halves the number of active threads\n"
"    // Each thread adds its partial sum[i] to sum[lane+i]\n"
"    for (int i = g.size() / 2; i > 0; i /= 2)\n"
"    {\n"
"        T next = g.shfl_down( val, i);\n"
"        val = GB_ADD( val, next ) ;\n"
"    }\n"
"    return val;\n"
"}\n"
"\n"
"template< typename T, int warp_sz>\n"
"__device__ __inline__ \n"
"T reduce_plus(thread_block_tile<warp_sz> g, T val)\n"
"{\n"
"    // Each iteration halves the number of active threads\n"
"    // Each thread adds its partial sum[i] to sum[lane+i]\n"
"    for (int i = g.size() / 2; i > 0; i /= 2)\n"
"    {\n"
"        val += g.shfl_down( val, i) ;\n"
"    }\n"
"    return val; // note: only thread 0 will return full sum and flag value\n"
"}\n"
"\n"
"#define intersects_per_thread 8\n"
"\n"
"template< typename T_C, typename T_A, typename T_B, typename T_X, typename T_Y, typename T_Z>  \n"
"__global__ void AxB_dot3_phase3_warp\n"
"(\n"
"    int64_t start,\n"
"    int64_t end,\n"
"    int64_t *Bucket,\n"
"    GrB_Matrix C,\n"
"    GrB_Matrix M,\n"
"    GrB_Matrix A,\n"
"    GrB_Matrix B,\n"
"    int sz\n"
")\n"
"{\n"
"\n"
"    T_A *Ax = (T_A*)A->x;\n"
"    T_B *Bx = (T_B*)B->x;\n"
"    T_C *Cx = (T_C*)C->x;\n"
"    int64_t *Ci = C->i;\n"
"    int64_t *Mi = M->i;\n"
"    int64_t *Ai = A->i;\n"
"    int64_t *Bi = B->i;\n"
"    int64_t *Ap = A->p;\n"
"    int64_t *Bp = B->p;\n"
"\n"
"\n"
"    // zombie count\n"
"    int zc = 0;\n"
"\n"
"    int64_t pair_id;\n"
"\n"
"    // set thread ID\n"
"    int tid_global = threadIdx.x+ blockDim.x* blockIdx.x;\n"
"    int tid = threadIdx.x;\n"
"\n"
"    int b = blockIdx.x ;\n"
"\n"
"    // total items to be inspected\n"
"    int64_t nnzA = 0;\n"
"    int64_t nnzB = 0;\n"
"    int64_t n_intersect = 0;\n"
"\n"
"    thread_block_tile<tile_sz> tile = tiled_partition<tile_sz>( this_thread_block());\n"
"\n"
"    //int parts = gridDim.x; //Each warp is a part\n"
"\n"
"    // Main loop over pairs \n"
"    for (pair_id = start +blockIdx.x; // 1 warp per pair \n"
"         pair_id < end;  \n"
"         pair_id += gridDim.x )\n"
"    {\n"
"\n"
"         int64_t i = Mi[pair_id];\n"
"         int64_t j = Ci[pair_id] >> 4;\n"
"\n"
"         int64_t pA = Ap[i];\n"
"         int64_t pA_end   = Ap[i+1];\n"
"         nnzA = pA_end - pA;\n"
"\n"
"         int64_t pB = Bp[j]; \n"
"         int64_t pB_end   = Bp[j+1]; \n"
"         nnzB = pB_end - pB;\n"
"\n"
"         n_intersect = INTMIN( nnzA, nnzB); \n"
"\n"
"         /*  only for multi-warp version\n"
"         if( tid ==0 ) {\n"
"            C->zombie_count = end - start;\n"
"            Ci[pair_id] = GB_FLIP(i);     // zombie until proven otherwise\n"
"            printf(\"block %d flipped indices for %lld %lld\\n\", b, i, j);\n"
"         }\n"
"         tile.sync(); \n"
"         */\n"
"\n"
"    int64_t nxy = nnzA + nnzB;\n"
"     /*\n"
"    int work_per_warp = (nxy +parts -1)/parts;\n"
"    int diag = INTMIN( work_per_warp*blockIdx.x, nxy);\n"
"    int diag_end = INTMIN( diag + work_per_warp, nxy);\n"
"    //printf(\" thd%d parts = %u wpt = %u diag, diag_end  = %u,%u\\n\",tid, parts, work_per_warp, diag, diag_end); \n"
"\n"
"    int x_min = INTMAX( (int)(diag - nnzB), 0);\n"
"    int x_max = INTMIN( diag, nnzA);\n"
"\n"
"    //printf(\"start thd%u x_min = %u x_max = %u\\n\", tid_global, x_min,x_max);\n"
"    while ( x_min < x_max) { //binary search for correct diag break\n"
"      int pivot = (x_min +x_max)/2;\n"
"      if ( Ai[pivot + pA] < Bi[ diag -pivot -1 + pB]) {\n"
"         x_min = pivot +1;\n"
"      }\n"
"      else {\n"
"         x_max = pivot;\n"
"      }\n"
"    }\n"
"    int xcoord = x_min;\n"
"    int ycoord = diag -x_min -1;\n"
"    if (( diag > 0) &&(diag < (nnzA+nnzB)) && (Ai[xcoord+pA] == Bi[ycoord+pB]) ) { \n"
"       diag--; //adjust for intersection incrementing both pointers \n"
"    }\n"
"    // two start points are known now\n"
"    int tx_start = xcoord +pA;\n"
"    int ty_start = diag -xcoord +pB; \n"
"\n"
"    //if (x_start != y_start)\n"
"    //   printf(\"start thd%u  xs,ys = %i,%i\\n\", tid_global, x_start, y_start);\n"
"\n"
"    x_min = INTMAX( (int)(diag_end - nnzB), 0);\n"
"    x_max = INTMIN( diag_end, nnzA);\n"
"\n"
"    while ( x_min < x_max) {\n"
"       int pivot = (x_min +x_max)/2;\n"
"       //printf(\"thd%u pre_sw piv=%u diag_e = %u  xmin,xmax=%u,%u\\n\", tid_global, pivot, diag_end,x_min, x_max);\n"
"       if ( Ai[pivot+ pA] < Bi[ diag_end -pivot -1 +pB]) {\n"
"          x_min = pivot +1;\n"
"       }\n"
"       else {\n"
"          x_max = pivot;\n"
"       }\n"
"       //printf(\"thd%u piv=%u xmin,xmax = %u,%u\\n\", tid_global, pivot, x_min, x_max);\n"
"    }\n"
"    xcoord = x_min;\n"
"    ycoord = diag_end -x_min -1;\n"
"    if ( (diag_end < (nnzA +nnzB)) && (Ai[xcoord +pA] == Bi[ycoord +pB]) ) { \n"
"        diag--; //adjust for intersection incrementing both pointers  \n"
"    }\n"
"    // two end points are known now\n"
"    int tx_end = xcoord +pA; \n"
"    int ty_end = diag_end - xcoord + pB; \n"
"\n"
"    */ \n"
"\n"
"    // No search, this warp does all the work\n"
"    int tx_start = pA;\n"
"    int tx_end   = pA_end;\n"
"    int ty_start = pB;\n"
"    int ty_end   = pB_end;\n"
"    /*\n"
"    if (threadIdx.x ==0 ) {\n"
"      printf(\"block %d dot %lld i,j= %lld,%lld\\n\", blockIdx.x, pair_id, i, j);\n"
"      printf(\"block %d dot %lld xs,xe= %d,%d ys,ye = %d,%d\\n\", \n"
"               blockIdx.x, pair_id, tx_start,tx_end, ty_start, ty_end);\n"
"    }\n"
"    tile.sync();\n"
"    */\n"
"\n"
"    // Warp intersection: balanced by design, no idle threads. \n"
"    // Each 32 thread warp will handle 32 comparisons per loop.\n"
"    // Either A or B takes stride 4, other takes stride 8\n"
"    // For this version A strides 4, B strides 8\n"
"    T_A aki;\n"
"    T_B bkj;\n"
"    T_Z cij = MONOID_IDENTITY ;\n"
"    int Astride = nnzA > nnzB ? 8 : 4;\n"
"    int Ashift  = nnzA > nnzB ? 3 : 2;\n"
"    int Amask   = nnzA > nnzB ? 7 : 3;\n"
"    int Bstride = nnzB >= nnzA ? 8 : 4;\n"
"    //printf(\" Astride = %d, Bstride = %d\\n\", Astride, Bstride);\n"
"\n"
"    // TODO PLUS_PAIR_INT64, FP32, FP64: no need for cij_exists.\n"
"    // just check if cij > 0\n"
"\n"
"    int cij_exists  = 0 ;\n"
"\n"
"    //Warp intersection dot product\n"
"    int bitty_row = tid &  Amask ;\n"
"    int bitty_col = tid >> Ashift ;\n"
"\n"
"    int k = tx_start + bitty_row ;\n"
"    int l = ty_start + bitty_col ;\n"
"    int inc_k, inc_l;\n"
"\n"
"    // int last_k = tx_start + 31%Astride ;\n"
"    // int last_l = ty_start + 31/Astride ;\n"
"\n"
"    //printf(\" thd%u has init value %d, k,l =%d, %d\\n\",tid, cij, k, l );\n"
"    while ( k < tx_end && l < ty_end )\n"
"    {\n"
"       if (Ai [k] == Bi [l])\n"
"       {\n"
"          GB_GETA ( aki=(T_Z)Ax[k] ) ;\n"
"          GB_GETB ( bkj=(T_Z)Bx[l] ) ;\n"
"          if (cij_exists)\n"
"          {\n"
"            T_Z t = GB_MULT( (T_Z) aki, (T_Z) bkj);\n"
"            cij = GB_ADD (cij, t ) ;\n"
"            //printf(\"  thd%d ix at %lld   cij += %d * %d \\n\", tid_global, Ai[k], aki, bkj);\n"
"          }\n"
"          else\n"
"          {\n"
"            cij_exists = 1 ;\n"
"            cij = GB_MULT ( (T_Z) aki, (T_Z) bkj) ;\n"
"            //printf(\"  thd%d ix at %lld   cij = %d * %d \\n\", tid_global, Ai[k], Ax[k], Bx[l]);\n"
"          }\n"
"          // TODO check terminal condition\n"
"          //printf(\" block%u work value = %d, exists = %d\\n\", b, cij, cij_exists);\n"
"       }\n"
"       if( tid == 31) // Last thread in the warp has the highest index.\n"
"       {\n"
"          inc_k = ( Ai[k] <  Bi[l]);\n"
"          inc_l = ( Ai[k] >= Bi[l]);\n"
"          k += inc_k ; // * Astride ; \n"
"          l += inc_l ; // * Bstride ; \n"
"          // last_k += inc_k * Astride ; \n"
"          // last_l += inc_l * Bstride ; \n"
"          //printf(\"block%d k = %d l= %d, Ai,Bi = %lld,%lld\\n\", b,  k, l, Ai[k], Bi[l]);\n"
"       }\n"
"       tile.sync();\n"
"       inc_k = tile.shfl_down( inc_k, 31-tid);\n"
"       if( inc_k) {\n"
"          k = tile.shfl_down(k,31-tid) + bitty_row ; // tid%Astride;\n"
"       }\n"
"       else {\n"
"          l = tile.shfl_down(l,31-tid) + bitty_col ; // tid/Astride;\n"
"       }\n"
"       //printf(\"block%d tid = %d k = %d l= %d\\n\", b, tid, k, l);\n"
"    }\n"
"\n"
"    //--------------------------------------------------------------------------\n"
"    // reduce sum per-thread values to a single scalar, get OR of flag\n"
"    //--------------------------------------------------------------------------\n"
"\n"
"    // Do vote here for control.\n"
"    cij_exists  = tile.any( cij_exists);\n"
"    tile.sync();\n"
"\n"
"    if (cij_exists)\n"
"    {\n"
"       cij = GB_reduce_sum<T_Z, tile_sz>( tile, cij );\n"
"    }\n"
"    tile.sync();\n"
"    \n"
"\n"
"    // Atomic write result for this block to global mem\n"
"    if (tid == 0)\n"
"    {\n"
"        //printf (\"final %d : %d exists = %d\\n\", b,  cij, cij_exists) ;\n"
"        if (cij_exists)\n"
"        {\n"
"           //printf(\" cij = %d\\n\", cij);\n"
"           //T_C old = atomicCAS( (T_C *)&(Cx[pair_id]), MONOID_IDENTITY, (T_C) cij ) ;\n"
"           //T_C assumed;\n"
"            GB_PUTC( Cx[pair_id] = (T_C) cij ) ;\n"
"           // Need ATOMIC_ADD here, use CAS on semi-ring operation  \n"
"           //if ( old != MONOID_IDENTITY) {\n"
"           //   do {\n"
"           //       assumed = old;\n"
"           //       old = atomicCAS( (T_C *)&(Cx[pair_id]), \n"
"           //                        assumed, \n"
"           //                        (T_C)( ADD( assumed, cij ) ) );\n"
"           //   }\n"
"           //  while (  assumed != old);\n"
"                \n"
"           //} \n"
"           //unsigned long long int old_i;\n"
"           //old_i = atomicCAS((unsigned long long int *)&(Ci[pair_id]),\n"
"           //                  (unsigned long long int)    GB_FLIP(i),  i ) ; \n"
"           //if ( old_i == GB_FLIP(i) ) {\n"
"           //   zc -= 1;  //decrement zombies, this one is alive\n"
"           //   atomicAdd( (unsigned long long int*)&(C->zombie_count), \n"
"           //              (unsigned long long int)zc);\n"
"           // }\n"
"           GB_PUTC ( Ci[pair_id] = i ) ;\n"
"           \n"
"        }\n"
"        else\n"
"        {\n"
"            //printf(\" dot %d is a zombie\\n\", pair_id);\n"
"            zc++;\n"
"            GB_PUTC ( Ci[pair_id] = GB_FLIP (i) ) ;\n"
"        }\n"
"    }\n"
"    //__syncthreads(); \n"
"  }\n"
"\n"
"  if( tid ==0 && zc > 0)\n"
"  {\n"
"      //printf(\"warp %d zombie count = %d\\n\", blockIdx.x, zc);\n"
"      atomicAdd( (unsigned long long int*)&(C->zombie_count), (unsigned long long int)zc);\n"
"      //printf(\"blk:%d Czombie = %lld\\n\",blockIdx.x,C->zombie_count);\n"
"  }\n"
"\n"
"}\n"
"\n"
;

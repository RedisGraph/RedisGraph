const char* const templates_GB_jit_AxB_dot3_phase3_spdn_cu = "templates/GB_jit_AxB_dot3_phase3_spdn.cu\n"
"//******************************************************************************\n"
"//  Sparse dot products in batch form, sparse - dense case. \n"
"//  Each thread in this kernel is responsible for m vector-pairs(x,y), \n"
"//  m = 256/sz, where sz is in {4, 16, 64, 256}\n"
"//  We know each non-zero on the sparse side will hit a dense value.\n"
"//  Template on <T_C, T_A, T_B, T_X, T_Y, T_Z >\n"
"//  Parameters:\n"
"\n"
"//  int64_t start          <- beginning of bucket  \n"
"//  int64_t end            <- end of bucket\n"
"//  int64_t *Bucket        <- index of each pair in this bucket\n"
"//  matrix<T_C> *C         <- C result matrix \n"
"//  matrix<T_C> *M         <- Mask matrix \n"
"//  matrix<T_A> *A         <- A matrix to multiply, sparse \n"
"//  matrix<T_B> *B         <- B matrix to multiply, dense in sparse format? \n"
"//  int sz                 <- size hint for smaller vector\n"
"//******************************************************************************\n"
"#include <limits>\n"
"#include <cstdint>\n"
"#include <stdio.h>\n"
"#include \"mySemiRing.h\"\n"
"#include \"matrix.h\"\n"
"\n"
"template< typename T_C, typename T_A, typename T_B, typename T_X, typename T_Y, typename T_Z>\n"
"__global__ void AxB_dot3_phase3_spdn\n"
"( \n"
"  int64_t start, \n"
"  int64_t end,\n"
"  int64_t *Bucket, \n"
"  GrB_Matrix C, \n"
"  GrB_Matrix M, \n"
"  GrB_Matrix A, \n"
"  GrB_Matrix B,\n"
"  int sz \n"
")\n"
"{\n"
"\n"
"   T_A *Ax = (T_A*)A->x;\n"
"   T_B *Bx = (T_B*)B->x;\n"
"   T_C *Cx = (T_C*)C->x;\n"
"   int64_t *Ci = C->i;\n"
"   int64_t *Mi = M->i;\n"
"   int64_t *Ai = A->i;\n"
"   int64_t *Bi = B->i;\n"
"   int64_t *Ap = A->p;\n"
"   int64_t *Bp = B->p;\n"
"\n"
"   // sz = expected non-zeros per dot \n"
"   int m = 256/sz;\n"
"   int nvecs = end - start;\n"
"   int dpt = nvecs/32;\n"
"   m = dpt < m ? dpt : m;\n"
"   //if( threadIdx.x ==0)\n"
"   //   printf(\"thd:%d %d dots/thrd, nvecs = %d blockDim=%d\\n\",threadIdx.x, sz, nvecs, blockDim.x);\n"
"   //__syncthreads();\n"
"   int dots = (nvecs +m -1)/m; \n"
"   int zc = 0;\n"
"     \n"
"   for ( int tid= threadIdx.x +blockDim.x*blockIdx.x;\n"
"             tid < dots;\n"
"             tid += blockDim.x * gridDim.x) {\n"
"      int pair_id, im; \n"
"       //if (threadIdx.x ==0)\n"
"       //  printf(\"thd%u pi=%lld\\n\",tid, start+threadIdx.x); \n"
"       //  __syncthreads();\n"
"\n"
"      for (pair_id = start+tid, im = 0; \n"
"           im < m && pair_id < end;  \n"
"           ++im,     pair_id += dots ){\n"
"\n"
"         int64_t i = Mi[pair_id];\n"
"         int64_t j = Ci[pair_id] >> 4;\n"
"      //if (threadIdx.x ==0)\n"
"      //   printf(\"thd%u i,j=%lld,%lld\\n\",tid, i,j); \n"
"      //   __syncthreads();\n"
"         \n"
"     //  printf(\"thd%d pi=%d xn=%lld yn=%lld\\n\",tid, pair_id, \n"
"     //                 A->p[i+1]- A->p[i],\n"
"     //                 B->p[j+1]- B->p[j]);\n"
"\n"
"         int64_t pA = Ap[i];\n"
"         int64_t pA_end   = Ap[i+1];\n"
"         int64_t nnzA   = pA_end - pA;\n"
"         int64_t pB = Bp[i];\n"
"         int64_t pB_end   = Bp[i+1];\n"
"         int64_t nnzB   = pB_end - pB;\n"
"         T_A aki;\n"
"         T_B bkj;\n"
"         T_Z cij;\n"
"\n"
"         if( nnzA == A->vlen) // A is dense\n"
"         {\n"
"            int64_t k = Bi [pB] ;               // first row index of B(:,j)\n"
"            // cij = A(k,i) * B(k,j)\n"
"            GB_GETA ( aki=(T_Z)Ax[pA+k] ) ;           // aki = A(k,i)\n"
"            GB_GETB ( bkj=(T_Z)Bx[pB] ) ;           // bkj = B(k,j)\n"
"            GB_C_MULT ( cij, aki, bkj ) ;           // cij = aki * bkj\n"
"\n"
"            for (int64_t p = pB+1 ; p < pB_end ; p++)\n"
"            { \n"
"                //GB_DOT_TERMINAL (cij) ;             // break if cij == terminal\n"
"                int64_t k = Bi [p] ;                // next row index of B(:,j)\n"
"                // cij += A(k,i) * B(k,j)\n"
"                GB_GETA ( aki=(T_Z)Ax[pA+k] ) ;           // aki = A(k,i)\n"
"                GB_GETB ( bkj=(T_Z)Bx[p] ) ;           // bkj = B(k,j)\n"
"                GB_MULTADD ( cij, aki, bkj ) ;        // cij += aki * bkj\n"
"            }\n"
"\n"
"         }\n"
"         if( nnzB == B->vlen) // B is dense\n"
"         {\n"
"            int64_t k = Ai [pA] ;               // first row index of A(:,i)\n"
"            // cij = A(k,i) * B(k,j)\n"
"            GB_GETA ( aki=(T_Z)Ax[ pA ] ) ;           // aki = A(k,i)\n"
"            GB_GETB ( bkj=(T_Z)Bx[ pB+k ] ) ;           // bkj = B(k,j)\n"
"            GB_C_MULT ( cij, aki, bkj) ;           // cij = aki * bkj\n"
"\n"
"            for (int64_t p = pA+1 ; p < pA_end ; p++)\n"
"            { \n"
"                //GB_DOT_TERMINAL (cij) ;             // break if cij == terminal\n"
"                int64_t k = Ai [p] ;                // next row index of A(:,i)\n"
"                // cij += A(k,i) * B(k,j)\n"
"                GB_GETA ( aki=(T_Z)Ax[ p ] ) ;           // aki = A(k,i)\n"
"                GB_GETB ( bkj=(T_Z)Bx[ pB+k] ) ;           // bkj = B(k,j)\n"
"                GB_MULTADD ( cij, aki, bkj) ;        // cij += aki * bkj\n"
"            }\n"
"         }\n"
"\n"
"         GB_PUTC( Ci[pair_id]=i ) ;\n"
"         GB_PUTC( Cx[pair_id]=cij ) ;\n"
"        \n"
"      }\n"
"  \n"
"   }\n"
"   \n"
"}\n"
;
